{"ast":null,"code":"import * as type from './type';\n\nfunction getBlobBuilder() {\n  if (typeof BlobBuilder !== 'undefined') {\n    return BlobBuilder;\n  } else if (typeof WebKitBlobBuilder !== 'undefined') {\n    return WebKitBlobBuilder;\n  } else {\n    return undefined;\n  }\n}\n/**\n * Concatenates one or more values together and converts them to a Blob.\n *\n * @param var_args The values that will make up the resulting blob.\n * @return The blob.\n */\n\n\nexport function getBlob() {\n  var var_args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    var_args[_i] = arguments[_i];\n  }\n\n  var BlobBuilder = getBlobBuilder();\n\n  if (BlobBuilder !== undefined) {\n    var bb = new BlobBuilder();\n\n    for (var i = 0; i < var_args.length; i++) {\n      bb.append(var_args[i]);\n    }\n\n    return bb.getBlob();\n  } else {\n    if (type.isNativeBlobDefined()) {\n      return new Blob(var_args);\n    } else {\n      throw Error(\"This browser doesn't seem to support creating Blobs\");\n    }\n  }\n}\n/**\n * Slices the blob. The returned blob contains data from the start byte\n * (inclusive) till the end byte (exclusive). Negative indices cannot be used.\n *\n * @param blob The blob to be sliced.\n * @param start Index of the starting byte.\n * @param end Index of the ending byte.\n * @return The blob slice or null if not supported.\n */\n\nexport function sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  } else if (blob.mozSlice) {\n    return blob.mozSlice(start, end);\n  } else if (blob.slice) {\n    return blob.slice(start, end);\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../src/implementation/fs.ts"],"names":[],"mappings":"AAqBA,OAAO,KAAK,IAAZ,MAAsB,QAAtB;;AAMA,SAAA,cAAA,GAAA;AACE,MAAI,OAAO,WAAP,KAAuB,WAA3B,EAAwC;AACtC,WAAO,WAAP;AACD,GAFD,MAEO,IAAI,OAAO,iBAAP,KAA6B,WAAjC,EAA8C;AACnD,WAAO,iBAAP;AACD,GAFM,MAEA;AACL,WAAO,SAAP;AACD;AACF;AAED;;;;;AAKG;;;AACH,OAAM,SAAA,OAAA,GAAA;AAAkB,MAAA,QAAA,GAAA,EAAA;;OAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAA4C;AAA5C,IAAA,QAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACtB,MAAI,WAAW,GAAG,cAAc,EAAhC;;AACA,MAAI,WAAW,KAAK,SAApB,EAA+B;AAC7B,QAAI,EAAE,GAAG,IAAI,WAAJ,EAAT;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACxC,MAAA,EAAE,CAAC,MAAH,CAAU,QAAQ,CAAC,CAAD,CAAlB;AACD;;AACD,WAAO,EAAE,CAAC,OAAH,EAAP;AACD,GAND,MAMO;AACL,QAAI,IAAI,CAAC,mBAAL,EAAJ,EAAgC;AAC9B,aAAO,IAAI,IAAJ,CAAS,QAAT,CAAP;AACD,KAFD,MAEO;AACL,YAAM,KAAK,CAAC,qDAAD,CAAX;AACD;AACF;AACF;AAED;;;;;;;;AAQG;;AACH,OAAM,SAAA,SAAA,CAAoB,IAApB,EAAgC,KAAhC,EAA+C,GAA/C,EAA0D;AAC9D,MAAK,IAAY,CAAC,WAAlB,EAA+B;AAC7B,WAAQ,IAAY,CAAC,WAAb,CAAyB,KAAzB,EAAgC,GAAhC,CAAR;AACD,GAFD,MAEO,IAAK,IAAY,CAAC,QAAlB,EAA4B;AACjC,WAAQ,IAAY,CAAC,QAAb,CAAsB,KAAtB,EAA6B,GAA7B,CAAR;AACD,GAFM,MAEA,IAAI,IAAI,CAAC,KAAT,EAAgB;AACrB,WAAO,IAAI,CAAC,KAAL,CAAW,KAAX,EAAkB,GAAlB,CAAP;AACD;;AACD,SAAO,IAAP;AACD","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Some methods copied from goog.fs.\n * We don't include goog.fs because it pulls in a bunch of Deferred code that\n * bloats the size of the released binary.\n */\nimport * as array from './array';\nimport * as type from './type';\n\ndeclare var IBlobBuilder;\ndeclare var BlobBuilder;\ndeclare var WebKitBlobBuilder;\n\nfunction getBlobBuilder(): (typeof IBlobBuilder) | undefined {\n  if (typeof BlobBuilder !== 'undefined') {\n    return BlobBuilder;\n  } else if (typeof WebKitBlobBuilder !== 'undefined') {\n    return WebKitBlobBuilder;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Concatenates one or more values together and converts them to a Blob.\n *\n * @param var_args The values that will make up the resulting blob.\n * @return The blob.\n */\nexport function getBlob(...var_args: (string | Blob | ArrayBuffer)[]): Blob {\n  let BlobBuilder = getBlobBuilder();\n  if (BlobBuilder !== undefined) {\n    let bb = new BlobBuilder();\n    for (let i = 0; i < var_args.length; i++) {\n      bb.append(var_args[i]);\n    }\n    return bb.getBlob();\n  } else {\n    if (type.isNativeBlobDefined()) {\n      return new Blob(var_args);\n    } else {\n      throw Error(\"This browser doesn't seem to support creating Blobs\");\n    }\n  }\n}\n\n/**\n * Slices the blob. The returned blob contains data from the start byte\n * (inclusive) till the end byte (exclusive). Negative indices cannot be used.\n *\n * @param blob The blob to be sliced.\n * @param start Index of the starting byte.\n * @param end Index of the ending byte.\n * @return The blob slice or null if not supported.\n */\nexport function sliceBlob(blob: Blob, start: number, end: number): Blob | null {\n  if ((blob as any).webkitSlice) {\n    return (blob as any).webkitSlice(start, end);\n  } else if ((blob as any).mozSlice) {\n    return (blob as any).mozSlice(start, end);\n  } else if (blob.slice) {\n    return blob.slice(start, end);\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}