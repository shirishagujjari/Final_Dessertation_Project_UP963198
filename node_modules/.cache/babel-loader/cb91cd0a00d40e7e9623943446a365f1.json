{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as array from './array';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\n\nexport function handlerCheck(cndn) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\nexport function metadataHandler(authWrapper, mappings) {\n  function handler(xhr, text) {\n    var metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);\n    handlerCheck(metadata !== null);\n    return metadata;\n  }\n\n  return handler;\n}\nexport function sharedErrorHandler(location) {\n  function errorHandler(xhr, err) {\n    var newErr;\n\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n\n  return errorHandler;\n}\nexport function objectErrorHandler(location) {\n  var shared = sharedErrorHandler(location);\n\n  function errorHandler(xhr, err) {\n    var newErr = shared(xhr, err);\n\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n\n  return errorHandler;\n}\nexport function getMetadata(authWrapper, location, mappings) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'GET';\n  var timeout = authWrapper.maxOperationRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function updateMetadata(authWrapper, location, metadata, mappings) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'PATCH';\n  var body = MetadataUtils.toResourceString(metadata, mappings);\n  var headers = {\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  var timeout = authWrapper.maxOperationRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function deleteObject(authWrapper, location) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'DELETE';\n  var timeout = authWrapper.maxOperationRetryTime();\n\n  function handler(xhr, text) {}\n\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function determineContentType_(metadata, blob) {\n  return metadata && metadata['contentType'] || blob && blob.type() || 'application/octet-stream';\n}\nexport function metadataForUpload_(location, blob, opt_metadata) {\n  var metadata = object.clone(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n\n  return metadata;\n}\nexport function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {\n  var urlPart = location.bucketOnlyServerUrl();\n  var headers = {\n    'X-Goog-Upload-Protocol': 'multipart'\n  };\n\n  function genBoundary() {\n    var str = '';\n\n    for (var i = 0; i < 2; i++) {\n      str = str + Math.random().toString().slice(2);\n    }\n\n    return str;\n  }\n\n  var boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  var metadata = metadataForUpload_(location, blob, opt_metadata);\n  var metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  var preBlobPart = '--' + boundary + '\\r\\n' + 'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' + metadataString + '\\r\\n--' + boundary + '\\r\\n' + 'Content-Type: ' + metadata['contentType'] + '\\r\\n\\r\\n';\n  var postBlobPart = '\\r\\n--' + boundary + '--';\n  var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  var urlParams = {\n    name: metadata['fullPath']\n  };\n  var url = UrlUtils.makeUploadUrl(urlPart);\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\n\nvar ResumableUploadStatus =\n/** @class */\nfunction () {\n  function ResumableUploadStatus(current, total, finalized, metadata) {\n    this.current = current;\n    this.total = total;\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n\n  return ResumableUploadStatus;\n}();\n\nexport { ResumableUploadStatus };\nexport function checkResumeHeader_(xhr, opt_allowed) {\n  var status;\n\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n\n  var allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return status;\n}\nexport function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {\n  var urlPart = location.bucketOnlyServerUrl();\n  var metadata = metadataForUpload_(location, blob, opt_metadata);\n  var urlParams = {\n    name: metadata['fullPath']\n  };\n  var url = UrlUtils.makeUploadUrl(urlPart);\n  var method = 'POST';\n  var headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  var body = MetadataUtils.toResourceString(metadata, mappings);\n  var timeout = authWrapper.maxUploadRetryTime();\n\n  function handler(xhr, text) {\n    checkResumeHeader_(xhr);\n    var url;\n\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n\n    handlerCheck(type.isString(url));\n    return url;\n  }\n\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\n\nexport function getResumableUploadStatus(authWrapper, location, url, blob) {\n  var headers = {\n    'X-Goog-Upload-Command': 'query'\n  };\n\n  function handler(xhr, text) {\n    var status = checkResumeHeader_(xhr, ['active', 'final']);\n    var sizeString;\n\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n\n    var size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\n\nexport var resumableUploadChunkSize = 256 * 1024;\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\n\nexport function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  var status = new ResumableUploadStatus(0, 0);\n\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n\n  var bytesLeft = status.total - status.current;\n  var bytesToUpload = bytesLeft;\n\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n\n  var startByte = status.current;\n  var endByte = startByte + bytesToUpload;\n  var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  var headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  var body = blob.slice(startByte, endByte);\n\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  function handler(xhr, text) {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    var newCurrent = status.current + bytesToUpload;\n    var size = blob.size();\n    var metadata;\n\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n\n    return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n  }\n\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}","map":{"version":3,"sources":["../src/implementation/requests.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines methods for interacting with the network.\n */\n\nimport { Metadata } from '../metadata';\n\nimport * as array from './array';\nimport { AuthWrapper } from './authwrapper';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport { FirebaseStorageError } from './error';\nimport { errors } from './error';\nimport { Location } from './location';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport { XhrIo } from './xhrio';\n\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn: boolean) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\n\nexport function metadataHandler(\n  authWrapper: AuthWrapper,\n  mappings: MetadataUtils.Mappings\n): (p1: XhrIo, p2: string) => Metadata {\n  function handler(xhr: XhrIo, text: string): Metadata {\n    let metadata = MetadataUtils.fromResourceString(\n      authWrapper,\n      text,\n      mappings\n    );\n    handlerCheck(metadata !== null);\n    return metadata as Metadata;\n  }\n  return handler;\n}\n\nexport function sharedErrorHandler(\n  location: Location\n): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  function errorHandler(\n    xhr: XhrIo,\n    err: FirebaseStorageError\n  ): FirebaseStorageError {\n    let newErr;\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function objectErrorHandler(\n  location: Location\n): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  let shared = sharedErrorHandler(location);\n\n  function errorHandler(\n    xhr: XhrIo,\n    err: FirebaseStorageError\n  ): FirebaseStorageError {\n    let newErr = shared(xhr, err);\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function getMetadata(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings\n): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'GET';\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function updateMetadata(\n  authWrapper: AuthWrapper,\n  location: Location,\n  metadata: Metadata,\n  mappings: MetadataUtils.Mappings\n): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'PATCH';\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let headers = { 'Content-Type': 'application/json; charset=utf-8' };\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function deleteObject(\n  authWrapper: AuthWrapper,\n  location: Location\n): RequestInfo<void> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'DELETE';\n  let timeout = authWrapper.maxOperationRetryTime();\n\n  function handler(xhr: XhrIo, text: string) {}\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function determineContentType_(\n  metadata: Metadata | null,\n  blob: FbsBlob | null\n): string {\n  return (\n    (metadata && metadata['contentType']) ||\n    (blob && blob.type()) ||\n    'application/octet-stream'\n  );\n}\n\nexport function metadataForUpload_(\n  location: Location,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): Metadata {\n  let metadata = object.clone<Metadata>(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n  return metadata;\n}\n\nexport function multipartUpload(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): RequestInfo<Metadata> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let headers: { [prop: string]: string } = {\n    'X-Goog-Upload-Protocol': 'multipart'\n  };\n\n  function genBoundary() {\n    let str = '';\n    for (let i = 0; i < 2; i++) {\n      str =\n        str +\n        Math.random()\n          .toString()\n          .slice(2);\n    }\n    return str;\n  }\n  let boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  let preBlobPart =\n    '--' +\n    boundary +\n    '\\r\\n' +\n    'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\n    metadataString +\n    '\\r\\n--' +\n    boundary +\n    '\\r\\n' +\n    'Content-Type: ' +\n    metadata['contentType'] +\n    '\\r\\n\\r\\n';\n  let postBlobPart = '\\r\\n--' + boundary + '--';\n  let body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  let urlParams = { name: metadata['fullPath'] };\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nexport class ResumableUploadStatus {\n  finalized: boolean;\n  metadata: Metadata | null;\n\n  constructor(\n    public current: number,\n    public total: number,\n    finalized?: boolean,\n    metadata?: Metadata | null\n  ) {\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n}\n\nexport function checkResumeHeader_(xhr: XhrIo, opt_allowed?: string[]): string {\n  let status;\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n  let allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return status as string;\n}\n\nexport function createResumableUpload(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): RequestInfo<string> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let urlParams = { name: metadata['fullPath'] };\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let timeout = authWrapper.maxUploadRetryTime();\n\n  function handler(xhr: XhrIo, text: string): string {\n    checkResumeHeader_(xhr);\n    let url;\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    handlerCheck(type.isString(url));\n    return url as string;\n  }\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(\n  authWrapper: AuthWrapper,\n  location: Location,\n  url: string,\n  blob: FbsBlob\n): RequestInfo<ResumableUploadStatus> {\n  let headers = { 'X-Goog-Upload-Command': 'query' };\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    let status = checkResumeHeader_(xhr, ['active', 'final']);\n    let sizeString;\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    let size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport const resumableUploadChunkSize: number = 256 * 1024;\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(\n  location: Location,\n  authWrapper: AuthWrapper,\n  url: string,\n  blob: FbsBlob,\n  chunkSize: number,\n  mappings: MetadataUtils.Mappings,\n  opt_status?: ResumableUploadStatus | null,\n  opt_progressCallback?: ((p1: number, p2: number) => void) | null\n): RequestInfo<ResumableUploadStatus> {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  let status = new ResumableUploadStatus(0, 0);\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n  let bytesLeft = status.total - status.current;\n  let bytesToUpload = bytesLeft;\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n  let startByte = status.current;\n  let endByte = startByte + bytesToUpload;\n  let uploadCommand =\n    bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  let headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  let body = blob.slice(startByte, endByte);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    let uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    let newCurrent = status.current + bytesToUpload;\n    let size = blob.size();\n    let metadata;\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n    return new ResumableUploadStatus(\n      newCurrent,\n      size,\n      uploadStatus === 'final',\n      metadata\n    );\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n"]},"metadata":{},"sourceType":"module"}