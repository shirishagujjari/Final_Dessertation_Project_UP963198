{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @param f May be invoked\n *     before the function returns.\n * @param callback Get all the arguments passed to the function\n *     passed to f, including the initial boolean.\n */\nexport function start(f, callback, timeout) {\n  // TODO(andysoto): make this code cleaner (probably refactor into an actual\n  // type instead of a bunch of functions with state shared in the closure)\n  var waitSeconds = 1; // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n\n  var timeoutId = null;\n  var hitTimeout = false;\n  var cancelState = 0;\n\n  function canceled() {\n    return cancelState === 2;\n  }\n\n  var triggeredCallback = false;\n\n  function triggerCallback() {\n    if (!triggeredCallback) {\n      triggeredCallback = true;\n      callback.apply(null, arguments);\n    }\n  }\n\n  function callWithDelay(millis) {\n    timeoutId = setTimeout(function () {\n      timeoutId = null;\n      f(handler, canceled());\n    }, millis);\n  }\n\n  function handler(success) {\n    var var_args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      var_args[_i - 1] = arguments[_i];\n    }\n\n    if (triggeredCallback) {\n      return;\n    }\n\n    if (success) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n\n    var mustStop = canceled() || hitTimeout;\n\n    if (mustStop) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n\n    if (waitSeconds < 64) {\n      /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n      waitSeconds *= 2;\n    }\n\n    var waitMillis;\n\n    if (cancelState === 1) {\n      cancelState = 2;\n      waitMillis = 0;\n    } else {\n      waitMillis = (waitSeconds + Math.random()) * 1000;\n    }\n\n    callWithDelay(waitMillis);\n  }\n\n  var stopped = false;\n\n  function stop(wasTimeout) {\n    if (stopped) {\n      return;\n    }\n\n    stopped = true;\n\n    if (triggeredCallback) {\n      return;\n    }\n\n    if (timeoutId !== null) {\n      if (!wasTimeout) {\n        cancelState = 2;\n      }\n\n      clearTimeout(timeoutId);\n      callWithDelay(0);\n    } else {\n      if (!wasTimeout) {\n        cancelState = 1;\n      }\n    }\n  }\n\n  callWithDelay(0);\n  setTimeout(function () {\n    hitTimeout = true;\n    stop(true);\n  }, timeout);\n  return stop;\n}\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\n\nexport function stop(id) {\n  id(false);\n}","map":{"version":3,"sources":["../src/implementation/backoff.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;AAUH;;;;;AAKG;AACH,OAAM,SAAA,KAAA,CACJ,CADI,EAKJ,QALI,EAMJ,OANI,EAMW;AAEf;AACA;AACA,MAAI,WAAW,GAAG,CAAlB,CAJe,CAKf;;AACA,MAAI,SAAS,GAAQ,IAArB;AACA,MAAI,UAAU,GAAG,KAAjB;AACA,MAAI,WAAW,GAAG,CAAlB;;AAEA,WAAA,QAAA,GAAA;AACE,WAAO,WAAW,KAAK,CAAvB;AACD;;AACD,MAAI,iBAAiB,GAAG,KAAxB;;AAEA,WAAA,eAAA,GAAA;AACE,QAAI,CAAC,iBAAL,EAAwB;AACtB,MAAA,iBAAiB,GAAG,IAApB;AACA,MAAA,QAAQ,CAAC,KAAT,CAAe,IAAf,EAAqB,SAArB;AACD;AACF;;AAED,WAAA,aAAA,CAAuB,MAAvB,EAAqC;AACnC,IAAA,SAAS,GAAG,UAAU,CAAC,YAAA;AACrB,MAAA,SAAS,GAAG,IAAZ;AACA,MAAA,CAAC,CAAC,OAAD,EAAU,QAAQ,EAAlB,CAAD;AACD,KAHqB,EAGnB,MAHmB,CAAtB;AAID;;AAED,WAAA,OAAA,CAAiB,OAAjB,EAAiC;AAAE,QAAA,QAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAkB;AAAlB,MAAA,QAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACjC,QAAI,iBAAJ,EAAuB;AACrB;AACD;;AACD,QAAI,OAAJ,EAAa;AACX,MAAA,eAAe,CAAC,KAAhB,CAAsB,IAAtB,EAA4B,SAA5B;AACA;AACD;;AACD,QAAI,QAAQ,GAAG,QAAQ,MAAM,UAA7B;;AACA,QAAI,QAAJ,EAAc;AACZ,MAAA,eAAe,CAAC,KAAhB,CAAsB,IAAtB,EAA4B,SAA5B;AACA;AACD;;AACD,QAAI,WAAW,GAAG,EAAlB,EAAsB;AACpB;AACA,MAAA,WAAW,IAAI,CAAf;AACD;;AACD,QAAI,UAAJ;;AACA,QAAI,WAAW,KAAK,CAApB,EAAuB;AACrB,MAAA,WAAW,GAAG,CAAd;AACA,MAAA,UAAU,GAAG,CAAb;AACD,KAHD,MAGO;AACL,MAAA,UAAU,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,MAAL,EAAf,IAAgC,IAA7C;AACD;;AACD,IAAA,aAAa,CAAC,UAAD,CAAb;AACD;;AACD,MAAI,OAAO,GAAG,KAAd;;AAEA,WAAA,IAAA,CAAc,UAAd,EAAiC;AAC/B,QAAI,OAAJ,EAAa;AACX;AACD;;AACD,IAAA,OAAO,GAAG,IAAV;;AACA,QAAI,iBAAJ,EAAuB;AACrB;AACD;;AACD,QAAI,SAAS,KAAK,IAAlB,EAAwB;AACtB,UAAI,CAAC,UAAL,EAAiB;AACf,QAAA,WAAW,GAAG,CAAd;AACD;;AACD,MAAA,YAAY,CAAC,SAAD,CAAZ;AACA,MAAA,aAAa,CAAC,CAAD,CAAb;AACD,KAND,MAMO;AACL,UAAI,CAAC,UAAL,EAAiB;AACf,QAAA,WAAW,GAAG,CAAd;AACD;AACF;AACF;;AACD,EAAA,aAAa,CAAC,CAAD,CAAb;AACA,EAAA,UAAU,CAAC,YAAA;AACT,IAAA,UAAU,GAAG,IAAb;AACA,IAAA,IAAI,CAAC,IAAD,CAAJ;AACD,GAHS,EAGP,OAHO,CAAV;AAIA,SAAO,IAAP;AACD;AAED;;;;;;AAMG;;AACH,OAAM,SAAA,IAAA,CAAe,EAAf,EAAqB;AACzB,EAAA,EAAE,CAAC,KAAD,CAAF;AACD","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides a method for running a function with exponential\n * backoff.\n */\ntype id = (p1: boolean) => void;\n\nexport { id };\n\n/**\n * @param f May be invoked\n *     before the function returns.\n * @param callback Get all the arguments passed to the function\n *     passed to f, including the initial boolean.\n */\nexport function start(\n  f: (\n    p1: (success: boolean, ...rest: any[]) => void,\n    canceled: boolean\n  ) => void,\n  callback: Function,\n  timeout: number\n): id {\n  // TODO(andysoto): make this code cleaner (probably refactor into an actual\n  // type instead of a bunch of functions with state shared in the closure)\n  let waitSeconds = 1;\n  // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n  let timeoutId: any = null;\n  let hitTimeout = false;\n  let cancelState = 0;\n\n  function canceled() {\n    return cancelState === 2;\n  }\n  let triggeredCallback = false;\n\n  function triggerCallback() {\n    if (!triggeredCallback) {\n      triggeredCallback = true;\n      callback.apply(null, arguments);\n    }\n  }\n\n  function callWithDelay(millis: number): void {\n    timeoutId = setTimeout(function() {\n      timeoutId = null;\n      f(handler, canceled());\n    }, millis);\n  }\n\n  function handler(success: boolean, ...var_args: any[]): void {\n    if (triggeredCallback) {\n      return;\n    }\n    if (success) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    let mustStop = canceled() || hitTimeout;\n    if (mustStop) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    if (waitSeconds < 64) {\n      /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n      waitSeconds *= 2;\n    }\n    let waitMillis;\n    if (cancelState === 1) {\n      cancelState = 2;\n      waitMillis = 0;\n    } else {\n      waitMillis = (waitSeconds + Math.random()) * 1000;\n    }\n    callWithDelay(waitMillis);\n  }\n  let stopped = false;\n\n  function stop(wasTimeout: boolean): void {\n    if (stopped) {\n      return;\n    }\n    stopped = true;\n    if (triggeredCallback) {\n      return;\n    }\n    if (timeoutId !== null) {\n      if (!wasTimeout) {\n        cancelState = 2;\n      }\n      clearTimeout(timeoutId);\n      callWithDelay(0);\n    } else {\n      if (!wasTimeout) {\n        cancelState = 1;\n      }\n    }\n  }\n  callWithDelay(0);\n  setTimeout(function() {\n    hitTimeout = true;\n    stop(true);\n  }, timeout);\n  return stop;\n}\n\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nexport function stop(id: id) {\n  id(false);\n}\n"]},"metadata":{},"sourceType":"module"}