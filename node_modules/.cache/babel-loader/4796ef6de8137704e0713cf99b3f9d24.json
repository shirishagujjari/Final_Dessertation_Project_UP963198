{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\nimport firebase from '@firebase/app';\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\n/**\n * @struct\n * @template T\n */\n\nvar NetworkRequest =\n/** @class */\nfunction () {\n  function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {\n    this.pendingXhr_ = null;\n    this.backoffId_ = null;\n    this.resolve_ = null;\n    this.reject_ = null;\n    this.canceled_ = false;\n    this.appDelete_ = false;\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    var self = this;\n    this.promise_ = promiseimpl.make(function (resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n  /**\n   * Actually starts the retry loop.\n   */\n\n\n  NetworkRequest.prototype.start_ = function () {\n    var self = this;\n\n    function doTheRequest(backoffCallback, canceled) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n\n      var xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n\n      function progressListener(progressEvent) {\n        var loaded = progressEvent.loaded;\n        var total = progressEvent.lengthComputable ? progressEvent.total : -1;\n\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n\n      xhr.send(self.url_, self.method_, self.body_, self.headers_).then(function (xhr) {\n        if (self.progressCallback_ !== null) {\n          xhr.removeUploadProgressListener(progressListener);\n        }\n\n        self.pendingXhr_ = null;\n        xhr = xhr;\n        var hitServer = xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n        var status = xhr.getStatus();\n\n        if (!hitServer || self.isRetryStatusCode_(status)) {\n          var wasCanceled = xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n          backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n          return;\n        }\n\n        var successCode = array.contains(self.successCodes_, status);\n        backoffCallback(true, new RequestEndStatus(successCode, xhr));\n      });\n    }\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n\n\n    function backoffDone(requestWentThrough, status) {\n      var resolve = self.resolve_;\n      var reject = self.reject_;\n      var xhr = status.xhr;\n\n      if (status.wasSuccessCode) {\n        try {\n          var result = self.callback_(xhr, xhr.getResponseText());\n\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          var err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            var err = self.appDelete_ ? errorsExports.appDeleted() : errorsExports.canceled();\n            reject(err);\n          } else {\n            var err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  };\n  /** @inheritDoc */\n\n\n  NetworkRequest.prototype.getPromise = function () {\n    return this.promise_;\n  };\n  /** @inheritDoc */\n\n\n  NetworkRequest.prototype.cancel = function (appDelete) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  };\n\n  NetworkRequest.prototype.isRetryStatusCode_ = function (status) {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    var isFiveHundredCode = status >= 500 && status < 600;\n    var extraRetryCodes = [// Request Timeout: web server didn't receive full request in time.\n    408, // Too Many Requests: you're getting rate-limited, basically.\n    429];\n    var isExtraRetryCode = array.contains(extraRetryCodes, status);\n    var isRequestSpecificRetryCode = array.contains(this.additionalRetryCodes_, status);\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  };\n\n  return NetworkRequest;\n}();\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\n\n\nvar RequestEndStatus =\n/** @class */\nfunction () {\n  function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) {\n    this.wasSuccessCode = wasSuccessCode;\n    this.xhr = xhr;\n    this.canceled = !!opt_canceled;\n  }\n\n  return RequestEndStatus;\n}();\n\nexport { RequestEndStatus };\nexport function addAuthHeader_(headers, authToken) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\nexport function addVersionHeader_(headers) {\n  var number = typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n/**\n * @template T\n */\n\nexport function makeRequest(requestInfo, authToken, pool) {\n  var queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  var url = requestInfo.url + queryPart;\n  var headers = object.clone(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);\n}","map":{"version":3,"sources":["../src/implementation/request.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;AAEH;;;AAGG;AAEH,OAAO,QAAP,MAA4C,eAA5C;AACA,OAAO,KAAK,KAAZ,MAAuB,SAAvB;AACA,OAAO,KAAK,OAAZ,MAAyB,WAAzB;AACA,OAAO,KAAK,aAAZ,MAA+B,SAA/B;AAGA,OAAO,KAAK,MAAZ,MAAwB,UAAxB;AACA,OAAO,KAAK,WAAZ,MAA6B,oBAA7B;AAEA,OAAO,KAAK,IAAZ,MAAsB,QAAtB;AACA,OAAO,KAAK,QAAZ,MAA0B,OAA1B;AACA,OAAO,KAAK,YAAZ,MAA8B,SAA9B;AAoBA;;;AAGG;;AACH,IAAA,cAAA;AAAA;AAAA,YAAA;AAsBE,WAAA,cAAA,CACE,GADF,EAEE,MAFF,EAGE,OAHF,EAIE,IAJF,EAKE,YALF,EAME,oBANF,EAOE,QAPF,EAQE,aARF,EAWE,OAXF,EAYE,gBAZF,EAaE,IAbF,EAaiB;AA5BT,SAAA,WAAA,GAA4B,IAA5B;AACA,SAAA,UAAA,GAAgC,IAAhC;AACA,SAAA,QAAA,GAA4B,IAA5B;AACA,SAAA,OAAA,GAA2B,IAA3B;AACA,SAAA,SAAA,GAAqB,KAArB;AACA,SAAA,UAAA,GAAsB,KAAtB;AAyBN,SAAK,IAAL,GAAY,GAAZ;AACA,SAAK,OAAL,GAAe,MAAf;AACA,SAAK,QAAL,GAAgB,OAAhB;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,aAAL,GAAqB,YAAY,CAAC,KAAb,EAArB;AACA,SAAK,qBAAL,GAA6B,oBAAoB,CAAC,KAArB,EAA7B;AACA,SAAK,SAAL,GAAiB,QAAjB;AACA,SAAK,cAAL,GAAsB,aAAtB;AACA,SAAK,iBAAL,GAAyB,gBAAzB;AACA,SAAK,QAAL,GAAgB,OAAhB;AACA,SAAK,KAAL,GAAa,IAAb;AACA,QAAI,IAAI,GAAG,IAAX;AACA,SAAK,QAAL,GAAgB,WAAW,CAAC,IAAZ,CAAiB,UAAS,OAAT,EAAkB,MAAlB,EAAwB;AACvD,MAAA,IAAI,CAAC,QAAL,GAAgB,OAAhB;AACA,MAAA,IAAI,CAAC,OAAL,GAAe,MAAf;AACA,MAAA,IAAI,CAAC,MAAL;AACD,KAJe,CAAhB;AAKD;AAED;;AAEG;;;AACK,EAAA,cAAA,CAAA,SAAA,CAAA,MAAA,GAAR,YAAA;AACE,QAAI,IAAI,GAAG,IAAX;;AAEA,aAAA,YAAA,CACE,eADF,EAEE,QAFF,EAEmB;AAEjB,UAAI,QAAJ,EAAc;AACZ,QAAA,eAAe,CAAC,KAAD,EAAQ,IAAI,gBAAJ,CAAqB,KAArB,EAA4B,IAA5B,EAAkC,IAAlC,CAAR,CAAf;AACA;AACD;;AACD,UAAI,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,WAAX,EAAV;AACA,MAAA,IAAI,CAAC,WAAL,GAAmB,GAAnB;;AAEA,eAAA,gBAAA,CAA0B,aAA1B,EAAsD;AACpD,YAAI,MAAM,GAAG,aAAa,CAAC,MAA3B;AACA,YAAI,KAAK,GAAG,aAAa,CAAC,gBAAd,GAAiC,aAAa,CAAC,KAA/C,GAAuD,CAAC,CAApE;;AACA,YAAI,IAAI,CAAC,iBAAL,KAA2B,IAA/B,EAAqC;AACnC,UAAA,IAAI,CAAC,iBAAL,CAAuB,MAAvB,EAA+B,KAA/B;AACD;AACF;;AACD,UAAI,IAAI,CAAC,iBAAL,KAA2B,IAA/B,EAAqC;AACnC,QAAA,GAAG,CAAC,yBAAJ,CAA8B,gBAA9B;AACD;;AACD,MAAA,GAAG,CACA,IADH,CACQ,IAAI,CAAC,IADb,EACmB,IAAI,CAAC,OADxB,EACiC,IAAI,CAAC,KADtC,EAC6C,IAAI,CAAC,QADlD,EAEG,IAFH,CAEQ,UAAS,GAAT,EAAmB;AACvB,YAAI,IAAI,CAAC,iBAAL,KAA2B,IAA/B,EAAqC;AACnC,UAAA,GAAG,CAAC,4BAAJ,CAAiC,gBAAjC;AACD;;AACD,QAAA,IAAI,CAAC,WAAL,GAAmB,IAAnB;AACA,QAAA,GAAG,GAAG,GAAN;AACA,YAAI,SAAS,GACX,GAAG,CAAC,YAAJ,OAAuB,YAAY,CAAC,SAAb,CAAuB,QADhD;AAEA,YAAI,MAAM,GAAG,GAAG,CAAC,SAAJ,EAAb;;AACA,YAAI,CAAC,SAAD,IAAc,IAAI,CAAC,kBAAL,CAAwB,MAAxB,CAAlB,EAAmD;AACjD,cAAI,WAAW,GACb,GAAG,CAAC,YAAJ,OAAuB,YAAY,CAAC,SAAb,CAAuB,KADhD;AAEA,UAAA,eAAe,CACb,KADa,EAEb,IAAI,gBAAJ,CAAqB,KAArB,EAA4B,IAA5B,EAAkC,WAAlC,CAFa,CAAf;AAIA;AACD;;AACD,YAAI,WAAW,GAAG,KAAK,CAAC,QAAN,CAAe,IAAI,CAAC,aAApB,EAAmC,MAAnC,CAAlB;AACA,QAAA,eAAe,CAAC,IAAD,EAAO,IAAI,gBAAJ,CAAqB,WAArB,EAAkC,GAAlC,CAAP,CAAf;AACD,OAtBH;AAuBD;AAED;;;AAGG;;;AACH,aAAA,WAAA,CACE,kBADF,EAEE,MAFF,EAE0B;AAExB,UAAI,OAAO,GAAG,IAAI,CAAC,QAAnB;AACA,UAAI,MAAM,GAAG,IAAI,CAAC,OAAlB;AACA,UAAI,GAAG,GAAG,MAAM,CAAC,GAAjB;;AACA,UAAI,MAAM,CAAC,cAAX,EAA2B;AACzB,YAAI;AACF,cAAI,MAAM,GAAG,IAAI,CAAC,SAAL,CAAe,GAAf,EAAoB,GAAG,CAAC,eAAJ,EAApB,CAAb;;AACA,cAAI,IAAI,CAAC,SAAL,CAAe,MAAf,CAAJ,EAA4B;AAC1B,YAAA,OAAO,CAAC,MAAD,CAAP;AACD,WAFD,MAEO;AACL,YAAA,OAAO;AACR;AACF,SAPD,CAOE,OAAO,CAAP,EAAU;AACV,UAAA,MAAM,CAAC,CAAD,CAAN;AACD;AACF,OAXD,MAWO;AACL,YAAI,GAAG,KAAK,IAAZ,EAAkB;AAChB,cAAI,GAAG,GAAG,aAAa,CAAC,OAAd,EAAV;AACA,UAAA,GAAG,CAAC,qBAAJ,CAA0B,GAAG,CAAC,eAAJ,EAA1B;;AACA,cAAI,IAAI,CAAC,cAAT,EAAyB;AACvB,YAAA,MAAM,CAAC,IAAI,CAAC,cAAL,CAAoB,GAApB,EAAyB,GAAzB,CAAD,CAAN;AACD,WAFD,MAEO;AACL,YAAA,MAAM,CAAC,GAAD,CAAN;AACD;AACF,SARD,MAQO;AACL,cAAI,MAAM,CAAC,QAAX,EAAqB;AACnB,gBAAI,GAAG,GAAG,IAAI,CAAC,UAAL,GACN,aAAa,CAAC,UAAd,EADM,GAEN,aAAa,CAAC,QAAd,EAFJ;AAGA,YAAA,MAAM,CAAC,GAAD,CAAN;AACD,WALD,MAKO;AACL,gBAAI,GAAG,GAAG,aAAa,CAAC,kBAAd,EAAV;AACA,YAAA,MAAM,CAAC,GAAD,CAAN;AACD;AACF;AACF;AACF;;AACD,QAAI,KAAK,SAAT,EAAoB;AAClB,MAAA,WAAW,CAAC,KAAD,EAAQ,IAAI,gBAAJ,CAAqB,KAArB,EAA4B,IAA5B,EAAkC,IAAlC,CAAR,CAAX;AACD,KAFD,MAEO;AACL,WAAK,UAAL,GAAkB,OAAO,CAAC,KAAR,CAAc,YAAd,EAA4B,WAA5B,EAAyC,KAAK,QAA9C,CAAlB;AACD;AACF,GAlGO;AAoGR;;;AACA,EAAA,cAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,WAAO,KAAK,QAAZ;AACD,GAFD;AAIA;;;AACA,EAAA,cAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,SAAP,EAA0B;AACxB,SAAK,SAAL,GAAiB,IAAjB;AACA,SAAK,UAAL,GAAkB,SAAS,IAAI,KAA/B;;AACA,QAAI,KAAK,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,MAAA,OAAO,CAAC,IAAR,CAAa,KAAK,UAAlB;AACD;;AACD,QAAI,KAAK,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAK,WAAL,CAAiB,KAAjB;AACD;AACF,GATD;;AAWQ,EAAA,cAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,MAA3B,EAAyC;AACvC;AACA;AACA,QAAI,iBAAiB,GAAG,MAAM,IAAI,GAAV,IAAiB,MAAM,GAAG,GAAlD;AACA,QAAI,eAAe,GAAG,CACpB;AACA,OAFoB,EAGpB;AACA,OAJoB,CAAtB;AAMA,QAAI,gBAAgB,GAAG,KAAK,CAAC,QAAN,CAAe,eAAf,EAAgC,MAAhC,CAAvB;AACA,QAAI,0BAA0B,GAAG,KAAK,CAAC,QAAN,CAC/B,KAAK,qBAD0B,EAE/B,MAF+B,CAAjC;AAIA,WAAO,iBAAiB,IAAI,gBAArB,IAAyC,0BAAhD;AACD,GAhBO;;AAiBV,SAAA,cAAA;AAAC,CAjMD,EAAA;AAmMA;;;;AAIG;;;AACH,IAAA,gBAAA;AAAA;AAAA,YAAA;AAME,WAAA,gBAAA,CACS,cADT,EAES,GAFT,EAGE,YAHF,EAGwB;AAFf,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,GAAA,GAAA,GAAA;AAGP,SAAK,QAAL,GAAgB,CAAC,CAAC,YAAlB;AACD;;AACH,SAAA,gBAAA;AAAC,CAbD,EAAA;;;AAeA,OAAM,SAAA,cAAA,CAAyB,OAAzB,EAA2C,SAA3C,EAAmE;AACvE,MAAI,SAAS,KAAK,IAAd,IAAsB,SAAS,CAAC,MAAV,GAAmB,CAA7C,EAAgD;AAC9C,IAAA,OAAO,CAAC,eAAD,CAAP,GAA2B,cAAc,SAAzC;AACD;AACF;AAED,OAAM,SAAA,iBAAA,CAA4B,OAA5B,EAA4C;AAChD,MAAI,MAAM,GACR,OAAO,QAAP,KAAoB,WAApB,GAAkC,QAAQ,CAAC,WAA3C,GAAyD,YAD3D;AAEA,EAAA,OAAO,CAAC,4BAAD,CAAP,GAAwC,WAAW,MAAnD;AACD;AAED;;AAEG;;AACH,OAAM,SAAA,WAAA,CACJ,WADI,EAEJ,SAFI,EAGJ,IAHI,EAGW;AAEf,MAAI,SAAS,GAAG,QAAQ,CAAC,eAAT,CAAyB,WAAW,CAAC,SAArC,CAAhB;AACA,MAAI,GAAG,GAAG,WAAW,CAAC,GAAZ,GAAkB,SAA5B;AACA,MAAI,OAAO,GAAG,MAAM,CAAC,KAAP,CAAsB,WAAW,CAAC,OAAlC,CAAd;AACA,EAAA,cAAc,CAAC,OAAD,EAAU,SAAV,CAAd;AACA,EAAA,iBAAiB,CAAC,OAAD,CAAjB;AACA,SAAO,IAAI,cAAJ,CACL,GADK,EAEL,WAAW,CAAC,MAFP,EAGL,OAHK,EAIL,WAAW,CAAC,IAJP,EAKL,WAAW,CAAC,YALP,EAML,WAAW,CAAC,oBANP,EAOL,WAAW,CAAC,OAPP,EAQL,WAAW,CAAC,YARP,EASL,WAAW,CAAC,OATP,EAUL,WAAW,CAAC,gBAVP,EAWL,IAXK,CAAP;AAaD","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\n\nimport firebase, { FirebaseNamespace } from '@firebase/app';\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport { FirebaseStorageError } from './error';\nimport { errors } from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\nimport { Headers, XhrIo } from './xhrio';\nimport { XhrIoPool } from './xhriopool';\n\n/**\n * @template T\n */\nexport interface Request<T> {\n  getPromise(): Promise<T>;\n\n  /**\n   * Cancels the request. IMPORTANT: the promise may still be resolved with an\n   * appropriate value (if the request is finished before you call this method,\n   * but the promise has not yet been resolved), so don't just assume it will be\n   * rejected if you call this function.\n   * @param appDelete True if the cancelation came from the app being deleted.\n   */\n  cancel(appDelete?: boolean): void;\n}\n\n/**\n * @struct\n * @template T\n */\nclass NetworkRequest<T> implements Request<T> {\n  private url_: string;\n  private method_: string;\n  private headers_: Headers;\n  private body_: string | Blob | Uint8Array | null;\n  private successCodes_: number[];\n  private additionalRetryCodes_: number[];\n  private pendingXhr_: XhrIo | null = null;\n  private backoffId_: backoff.id | null = null;\n  private resolve_: Function | null = null;\n  private reject_: Function | null = null;\n  private canceled_: boolean = false;\n  private appDelete_: boolean = false;\n  private callback_: (p1: XhrIo, p2: string) => T;\n  private errorCallback_:\n    | ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError)\n    | null;\n  private progressCallback_: ((p1: number, p2: number) => void) | null;\n  private timeout_: number;\n  private pool_: XhrIoPool;\n  promise_: Promise<T>;\n\n  constructor(\n    url: string,\n    method: string,\n    headers: Headers,\n    body: string | Blob | Uint8Array | null,\n    successCodes: number[],\n    additionalRetryCodes: number[],\n    callback: (p1: XhrIo, p2: string) => T,\n    errorCallback:\n      | ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError)\n      | null,\n    timeout: number,\n    progressCallback: ((p1: number, p2: number) => void) | null,\n    pool: XhrIoPool\n  ) {\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    let self = this;\n    this.promise_ = promiseimpl.make(function(resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n\n  /**\n   * Actually starts the retry loop.\n   */\n  private start_() {\n    let self = this;\n\n    function doTheRequest(\n      backoffCallback: (p1: boolean, ...p2: any[]) => void,\n      canceled: boolean\n    ) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n      let xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n\n      function progressListener(progressEvent: ProgressEvent) {\n        let loaded = progressEvent.loaded;\n        let total = progressEvent.lengthComputable ? progressEvent.total : -1;\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n      xhr\n        .send(self.url_, self.method_, self.body_, self.headers_)\n        .then(function(xhr: XhrIo) {\n          if (self.progressCallback_ !== null) {\n            xhr.removeUploadProgressListener(progressListener);\n          }\n          self.pendingXhr_ = null;\n          xhr = xhr as XhrIo;\n          let hitServer =\n            xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n          let status = xhr.getStatus();\n          if (!hitServer || self.isRetryStatusCode_(status)) {\n            let wasCanceled =\n              xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n            backoffCallback(\n              false,\n              new RequestEndStatus(false, null, wasCanceled)\n            );\n            return;\n          }\n          let successCode = array.contains(self.successCodes_, status);\n          backoffCallback(true, new RequestEndStatus(successCode, xhr));\n        });\n    }\n\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n    function backoffDone(\n      requestWentThrough: boolean,\n      status: RequestEndStatus\n    ) {\n      let resolve = self.resolve_ as Function;\n      let reject = self.reject_ as Function;\n      let xhr = status.xhr as XhrIo;\n      if (status.wasSuccessCode) {\n        try {\n          let result = self.callback_(xhr, xhr.getResponseText());\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          let err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            let err = self.appDelete_\n              ? errorsExports.appDeleted()\n              : errorsExports.canceled();\n            reject(err);\n          } else {\n            let err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  }\n\n  /** @inheritDoc */\n  getPromise() {\n    return this.promise_;\n  }\n\n  /** @inheritDoc */\n  cancel(appDelete?: boolean) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  }\n\n  private isRetryStatusCode_(status: number): boolean {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    let isFiveHundredCode = status >= 500 && status < 600;\n    let extraRetryCodes = [\n      // Request Timeout: web server didn't receive full request in time.\n      408,\n      // Too Many Requests: you're getting rate-limited, basically.\n      429\n    ];\n    let isExtraRetryCode = array.contains(extraRetryCodes, status);\n    let isRequestSpecificRetryCode = array.contains(\n      this.additionalRetryCodes_,\n      status\n    );\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  }\n}\n\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nexport class RequestEndStatus {\n  /**\n   * True if the request was canceled.\n   */\n  canceled: boolean;\n\n  constructor(\n    public wasSuccessCode: boolean,\n    public xhr: XhrIo | null,\n    opt_canceled?: boolean\n  ) {\n    this.canceled = !!opt_canceled;\n  }\n}\n\nexport function addAuthHeader_(headers: Headers, authToken: string | null) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\n\nexport function addVersionHeader_(headers: Headers) {\n  let number =\n    typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n\n/**\n * @template T\n */\nexport function makeRequest<T>(\n  requestInfo: RequestInfo<T>,\n  authToken: string | null,\n  pool: XhrIoPool\n): Request<T> {\n  let queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  let url = requestInfo.url + queryPart;\n  let headers = object.clone<Headers>(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest<T>(\n    url,\n    requestInfo.method,\n    headers,\n    requestInfo.body,\n    requestInfo.successCodes,\n    requestInfo.additionalRetryCodes,\n    requestInfo.handler,\n    requestInfo.errorHandler,\n    requestInfo.timeout,\n    requestInfo.progressCallback,\n    pool\n  );\n}\n"]},"metadata":{},"sourceType":"module"}