{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Observer } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport * as errors from './implementation/error';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\n\nvar UploadTask =\n/** @class */\nfunction () {\n  /**\n   * @param ref The firebaseStorage.Reference object this task came\n   *     from, untyped to avoid cyclic dependencies.\n   * @param blob The blob to upload.\n   */\n  function UploadTask(ref, authWrapper, location, mappings, blob, metadata) {\n    if (metadata === void 0) {\n      metadata = null;\n    }\n\n    var _this = this;\n\n    this.transferred_ = 0;\n    this.needToFetchStatus_ = false;\n    this.needToFetchMetadata_ = false;\n    this.observers_ = [];\n    this.error_ = null;\n    this.uploadUrl_ = null;\n    this.request_ = null;\n    this.chunkMultiplier_ = 1;\n    this.resolve_ = null;\n    this.reject_ = null;\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n\n    this.errorHandler_ = function (error) {\n      _this.request_ = null;\n      _this.chunkMultiplier_ = 1;\n\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        _this.needToFetchStatus_ = true;\n\n        _this.completeTransitions_();\n      } else {\n        _this.error_ = error;\n\n        _this.transition_(InternalTaskState.ERROR);\n      }\n    };\n\n    this.metadataErrorHandler_ = function (error) {\n      _this.request_ = null;\n\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        _this.completeTransitions_();\n      } else {\n        _this.error_ = error;\n\n        _this.transition_(InternalTaskState.ERROR);\n      }\n    };\n\n    this.promise_ = fbsPromiseimpl.make(function (resolve, reject) {\n      _this.resolve_ = resolve;\n      _this.reject_ = reject;\n\n      _this.start_();\n    }); // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n\n    this.promise_.then(null, function () {});\n  }\n\n  UploadTask.prototype.makeProgressCallback_ = function () {\n    var _this = this;\n\n    var sizeBefore = this.transferred_;\n    return function (loaded, total) {\n      _this.updateProgress_(sizeBefore + loaded);\n    };\n  };\n\n  UploadTask.prototype.shouldDoResumable_ = function (blob) {\n    return blob.size() > 256 * 1024;\n  };\n\n  UploadTask.prototype.start_ = function () {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n\n    if (this.request_ !== null) {\n      return;\n    }\n\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  };\n\n  UploadTask.prototype.resolveToken_ = function (callback) {\n    var _this = this;\n\n    this.authWrapper_.getAuthToken().then(function (authToken) {\n      switch (_this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n\n        case InternalTaskState.CANCELING:\n          _this.transition_(InternalTaskState.CANCELED);\n\n          break;\n\n        case InternalTaskState.PAUSING:\n          _this.transition_(InternalTaskState.PAUSED);\n\n          break;\n\n        default:\n      }\n    });\n  }; // TODO(andysoto): assert false\n\n\n  UploadTask.prototype.createResumable_ = function () {\n    var _this = this;\n\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.createResumableUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n\n      var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = createRequest;\n      createRequest.getPromise().then(function (url) {\n        _this.request_ = null;\n        _this.uploadUrl_ = url;\n        _this.needToFetchStatus_ = false;\n\n        _this.completeTransitions_();\n      }, _this.errorHandler_);\n    });\n  };\n\n  UploadTask.prototype.fetchStatus_ = function () {\n    var _this = this; // TODO(andysoto): assert(this.uploadUrl_ !== null);\n\n\n    var url = this.uploadUrl_;\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.getResumableUploadStatus(_this.authWrapper_, _this.location_, url, _this.blob_);\n\n      var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = statusRequest;\n      statusRequest.getPromise().then(function (status) {\n        status = status;\n        _this.request_ = null;\n\n        _this.updateProgress_(status.current);\n\n        _this.needToFetchStatus_ = false;\n\n        if (status.finalized) {\n          _this.needToFetchMetadata_ = true;\n        }\n\n        _this.completeTransitions_();\n      }, _this.errorHandler_);\n    });\n  };\n\n  UploadTask.prototype.continueUpload_ = function () {\n    var _this = this;\n\n    var chunkSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    var status = new fbsRequests.ResumableUploadStatus(this.transferred_, this.blob_.size()); // TODO(andysoto): assert(this.uploadUrl_ !== null);\n\n    var url = this.uploadUrl_;\n    this.resolveToken_(function (authToken) {\n      var requestInfo;\n\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());\n      } catch (e) {\n        _this.error_ = e;\n\n        _this.transition_(InternalTaskState.ERROR);\n\n        return;\n      }\n\n      var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = uploadRequest;\n      uploadRequest.getPromise().then(function (newStatus) {\n        _this.increaseMultiplier_();\n\n        _this.request_ = null;\n\n        _this.updateProgress_(newStatus.current);\n\n        if (newStatus.finalized) {\n          _this.metadata_ = newStatus.metadata;\n\n          _this.transition_(InternalTaskState.SUCCESS);\n        } else {\n          _this.completeTransitions_();\n        }\n      }, _this.errorHandler_);\n    });\n  };\n\n  UploadTask.prototype.increaseMultiplier_ = function () {\n    var currentSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_; // Max chunk size is 32M.\n\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  };\n\n  UploadTask.prototype.fetchMetadata_ = function () {\n    var _this = this;\n\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.getMetadata(_this.authWrapper_, _this.location_, _this.mappings_);\n\n      var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(function (metadata) {\n        _this.request_ = null;\n        _this.metadata_ = metadata;\n\n        _this.transition_(InternalTaskState.SUCCESS);\n      }, _this.metadataErrorHandler_);\n    });\n  };\n\n  UploadTask.prototype.oneShotUpload_ = function () {\n    var _this = this;\n\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.multipartUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n\n      var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(function (metadata) {\n        _this.request_ = null;\n        _this.metadata_ = metadata;\n\n        _this.updateProgress_(_this.blob_.size());\n\n        _this.transition_(InternalTaskState.SUCCESS);\n      }, _this.errorHandler_);\n    });\n  };\n\n  UploadTask.prototype.updateProgress_ = function (transferred) {\n    var old = this.transferred_;\n    this.transferred_ = transferred; // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  };\n\n  UploadTask.prototype.transition_ = function (state) {\n    if (this.state_ === state) {\n      return;\n    }\n\n    switch (state) {\n      case InternalTaskState.CANCELING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n\n        break;\n\n      case InternalTaskState.PAUSING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n\n        break;\n\n      case InternalTaskState.RUNNING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        var wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n\n        break;\n\n      case InternalTaskState.PAUSED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n\n      case InternalTaskState.CANCELED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n\n      case InternalTaskState.ERROR:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n\n      case InternalTaskState.SUCCESS:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  };\n\n  UploadTask.prototype.completeTransitions_ = function () {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n\n      default:\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  };\n\n  Object.defineProperty(UploadTask.prototype, \"snapshot\", {\n    get: function () {\n      var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n      return new UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Adds a callback for an event.\n   * @param type The type of event to listen for.\n   */\n\n  UploadTask.prototype.on = function (type, nextOrObserver, error, completed) {\n    if (nextOrObserver === void 0) {\n      nextOrObserver = undefined;\n    }\n\n    if (error === void 0) {\n      error = undefined;\n    }\n\n    if (completed === void 0) {\n      completed = undefined;\n    }\n\n    function typeValidator(_p) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw \"Expected one of the event types: [\" + TaskEvent.STATE_CHANGED + \"].\";\n      }\n    }\n\n    var nextOrObserverMessage = 'Expected a function or an Object with one of ' + '`next`, `error`, `complete` properties.';\n    var nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    var observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n\n    function nextOrObserverValidator(p) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {}\n\n      try {\n        observerValidator(p);\n        var anyDefined = typeUtils.isJustDef(p['next']) || typeUtils.isJustDef(p['error']) || typeUtils.isJustDef(p['complete']);\n\n        if (!anyDefined) {\n          throw '';\n        }\n\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n\n    var specs = [fbsArgs.stringSpec(typeValidator), fbsArgs.looseObjectSpec(nextOrObserverValidator, true), fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)];\n    fbsArgs.validate('on', specs, arguments);\n    var self = this;\n\n    function makeBinder(specs) {\n      function binder(nextOrObserver, error, opt_complete) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n\n        var observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return function () {\n          self.removeObserver_(observer);\n        };\n      }\n\n      return binder;\n    }\n\n    function binderNextOrObserverValidator(p) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n\n      nextOrObserverValidator(p);\n    }\n\n    var binderSpecs = [fbsArgs.looseObjectSpec(binderNextOrObserverValidator), fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)];\n    var typeOnly = !(typeUtils.isJustDef(nextOrObserver) || typeUtils.isJustDef(error) || typeUtils.isJustDef(completed));\n\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  };\n  /**\n   * This object behaves like a Promise, and resolves with its snapshot data\n   * when the upload completes.\n   * @param onFulfilled The fulfillment callback. Promise chaining works as normal.\n   * @param onRejected The rejection callback.\n   */\n\n\n  UploadTask.prototype.then = function (onFulfilled, onRejected) {\n    // These casts are needed so that TypeScript can infer the types of the\n    // resulting Promise.\n    return this.promise_.then(onFulfilled, onRejected);\n  };\n  /**\n   * Equivalent to calling `then(null, onRejected)`.\n   */\n\n\n  UploadTask.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n  /**\n   * Adds the given observer.\n   */\n\n\n  UploadTask.prototype.addObserver_ = function (observer) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  };\n  /**\n   * Removes the given observer.\n   */\n\n\n  UploadTask.prototype.removeObserver_ = function (observer) {\n    fbsArray.remove(this.observers_, observer);\n  };\n\n  UploadTask.prototype.notifyObservers_ = function () {\n    var _this = this;\n\n    this.finishPromise_();\n    var observers = fbsArray.clone(this.observers_);\n    observers.forEach(function (observer) {\n      _this.notifyObserver_(observer);\n    });\n  };\n\n  UploadTask.prototype.finishPromise_ = function () {\n    if (this.resolve_ !== null) {\n      var triggered = true;\n\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          var toCall = this.reject_;\n          fbsAsync(toCall.bind(null, this.error_))();\n          break;\n\n        default:\n          triggered = false;\n          break;\n      }\n\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  };\n\n  UploadTask.prototype.notifyObserver_ = function (observer) {\n    var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n\n        break;\n\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n\n        break;\n\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_))();\n        }\n\n        break;\n\n      default:\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_))();\n        }\n\n    }\n  };\n  /**\n   * Resumes a paused task. Has no effect on a currently running or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n\n\n  UploadTask.prototype.resume = function () {\n    fbsArgs.validate('resume', [], arguments);\n    var valid = this.state_ === InternalTaskState.PAUSED || this.state_ === InternalTaskState.PAUSING;\n\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n\n    return valid;\n  };\n  /**\n   * Pauses a currently running task. Has no effect on a paused or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n\n\n  UploadTask.prototype.pause = function () {\n    fbsArgs.validate('pause', [], arguments);\n    var valid = this.state_ === InternalTaskState.RUNNING;\n\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n\n    return valid;\n  };\n  /**\n   * Cancels a currently running or paused task. Has no effect on a complete or\n   * failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n\n\n  UploadTask.prototype.cancel = function () {\n    fbsArgs.validate('cancel', [], arguments);\n    var valid = this.state_ === InternalTaskState.RUNNING || this.state_ === InternalTaskState.PAUSING;\n\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n\n    return valid;\n  };\n\n  return UploadTask;\n}();\n\nexport { UploadTask };","map":{"version":3,"sources":["../src/task.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\n\nimport { AuthWrapper } from './implementation/authwrapper';\nimport { FbsBlob } from './implementation/blob';\nimport { FirebaseStorageError } from './implementation/error';\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Metadata } from './metadata';\nimport {\n  NextFn,\n  ErrorFn,\n  CompleteFn,\n  Unsubscribe,\n  Observer\n} from './implementation/observer';\nimport { Request } from './implementation/request';\nimport * as RequestExports from './implementation/request';\nimport { Subscribe } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport { ArgSpec } from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport { errors as fbsErrors } from './implementation/error';\nimport * as errors from './implementation/error';\nimport { Location } from './implementation/location';\nimport * as fbsMetadata from './implementation/metadata';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport { RequestInfo } from './implementation/requestinfo';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\nimport { Reference } from './reference';\n\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nexport class UploadTask {\n  private ref_: Reference;\n  private authWrapper_: AuthWrapper;\n  private location_: Location;\n  private blob_: FbsBlob;\n  private metadata_: Metadata | null;\n  private mappings_: fbsMetadata.Mappings;\n  private transferred_: number = 0;\n  private needToFetchStatus_: boolean = false;\n  private needToFetchMetadata_: boolean = false;\n  private observers_: Observer<UploadTaskSnapshot>[] = [];\n  private resumable_: boolean;\n  private state_: InternalTaskState;\n  private error_: Error | null = null;\n  private uploadUrl_: string | null = null;\n  private request_: Request<any> | null = null;\n  private chunkMultiplier_: number = 1;\n  private errorHandler_: (p1: FirebaseStorageError) => void;\n  private metadataErrorHandler_: (p1: FirebaseStorageError) => void;\n  private resolve_: ((p1: UploadTaskSnapshot) => void) | null = null;\n  private reject_: ((p1: Error) => void) | null = null;\n  private promise_: Promise<UploadTaskSnapshot>;\n\n  /**\n   * @param ref The firebaseStorage.Reference object this task came\n   *     from, untyped to avoid cyclic dependencies.\n   * @param blob The blob to upload.\n   */\n  constructor(\n    ref: Reference,\n    authWrapper: AuthWrapper,\n    location: Location,\n    mappings: fbsMetadata.Mappings,\n    blob: FbsBlob,\n    metadata: Metadata | null = null\n  ) {\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n    this.errorHandler_ = error => {\n      this.request_ = null;\n      this.chunkMultiplier_ = 1;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.needToFetchStatus_ = true;\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.metadataErrorHandler_ = error => {\n      this.request_ = null;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.promise_ = fbsPromiseimpl.make((resolve, reject) => {\n      this.resolve_ = resolve;\n      this.reject_ = reject;\n      this.start_();\n    });\n\n    // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n    this.promise_.then(null, () => {});\n  }\n\n  private makeProgressCallback_(): (p1: number, p2: number) => void {\n    const sizeBefore = this.transferred_;\n    return (loaded, total) => {\n      this.updateProgress_(sizeBefore + loaded);\n    };\n  }\n\n  private shouldDoResumable_(blob: FbsBlob): boolean {\n    return blob.size() > 256 * 1024;\n  }\n\n  private start_() {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n    if (this.request_ !== null) {\n      return;\n    }\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  }\n\n  private resolveToken_(callback: (p1: string | null) => void) {\n    this.authWrapper_.getAuthToken().then(authToken => {\n      switch (this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n        case InternalTaskState.CANCELING:\n          this.transition_(InternalTaskState.CANCELED);\n          break;\n        case InternalTaskState.PAUSING:\n          this.transition_(InternalTaskState.PAUSED);\n          break;\n        default:\n      }\n    });\n  }\n\n  // TODO(andysoto): assert false\n\n  private createResumable_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.createResumableUpload(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_,\n        this.blob_,\n        this.metadata_\n      );\n      const createRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = createRequest;\n      createRequest.getPromise().then((url: string) => {\n        this.request_ = null;\n        this.uploadUrl_ = url;\n        this.needToFetchStatus_ = false;\n        this.completeTransitions_();\n      }, this.errorHandler_);\n    });\n  }\n\n  private fetchStatus_() {\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = this.uploadUrl_ as string;\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.getResumableUploadStatus(\n        this.authWrapper_,\n        this.location_,\n        url,\n        this.blob_\n      );\n      const statusRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = statusRequest;\n      statusRequest.getPromise().then(status => {\n        status = status as fbsRequests.ResumableUploadStatus;\n        this.request_ = null;\n        this.updateProgress_(status.current);\n        this.needToFetchStatus_ = false;\n        if (status.finalized) {\n          this.needToFetchMetadata_ = true;\n        }\n        this.completeTransitions_();\n      }, this.errorHandler_);\n    });\n  }\n\n  private continueUpload_() {\n    const chunkSize =\n      fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    const status = new fbsRequests.ResumableUploadStatus(\n      this.transferred_,\n      this.blob_.size()\n    );\n\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = this.uploadUrl_ as string;\n    this.resolveToken_(authToken => {\n      let requestInfo;\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(\n          this.location_,\n          this.authWrapper_,\n          url,\n          this.blob_,\n          chunkSize,\n          this.mappings_,\n          status,\n          this.makeProgressCallback_()\n        );\n      } catch (e) {\n        this.error_ = e;\n        this.transition_(InternalTaskState.ERROR);\n        return;\n      }\n      const uploadRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = uploadRequest;\n      uploadRequest\n        .getPromise()\n        .then((newStatus: fbsRequests.ResumableUploadStatus) => {\n          this.increaseMultiplier_();\n          this.request_ = null;\n          this.updateProgress_(newStatus.current);\n          if (newStatus.finalized) {\n            this.metadata_ = newStatus.metadata;\n            this.transition_(InternalTaskState.SUCCESS);\n          } else {\n            this.completeTransitions_();\n          }\n        }, this.errorHandler_);\n    });\n  }\n\n  private increaseMultiplier_() {\n    const currentSize =\n      fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n\n    // Max chunk size is 32M.\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  }\n\n  private fetchMetadata_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.getMetadata(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_\n      );\n      const metadataRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(metadata => {\n        this.request_ = null;\n        this.metadata_ = metadata;\n        this.transition_(InternalTaskState.SUCCESS);\n      }, this.metadataErrorHandler_);\n    });\n  }\n\n  private oneShotUpload_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.multipartUpload(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_,\n        this.blob_,\n        this.metadata_\n      );\n      const multipartRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(metadata => {\n        this.request_ = null;\n        this.metadata_ = metadata;\n        this.updateProgress_(this.blob_.size());\n        this.transition_(InternalTaskState.SUCCESS);\n      }, this.errorHandler_);\n    });\n  }\n\n  private updateProgress_(transferred: number) {\n    const old = this.transferred_;\n    this.transferred_ = transferred;\n\n    // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  }\n\n  private transition_(state: InternalTaskState) {\n    if (this.state_ === state) {\n      return;\n    }\n    switch (state) {\n      case InternalTaskState.CANCELING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.PAUSING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.RUNNING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        const wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n        break;\n      case InternalTaskState.PAUSED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.CANCELED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.ERROR:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.SUCCESS:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  }\n\n  private completeTransitions_() {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  }\n\n  get snapshot(): UploadTaskSnapshot {\n    const externalState = fbsTaskEnums.taskStateFromInternalTaskState(\n      this.state_\n    );\n    return new UploadTaskSnapshot(\n      this.transferred_,\n      this.blob_.size(),\n      externalState,\n      this.metadata_,\n      this,\n      this.ref_\n    );\n  }\n\n  /**\n   * Adds a callback for an event.\n   * @param type The type of event to listen for.\n   */\n  on(\n    type: TaskEvent,\n    nextOrObserver = undefined,\n    error = undefined,\n    completed = undefined\n  ): Unsubscribe | Subscribe<UploadTaskSnapshot> {\n    function typeValidator(_p: any) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw `Expected one of the event types: [${TaskEvent.STATE_CHANGED}].`;\n      }\n    }\n    const nextOrObserverMessage =\n      'Expected a function or an Object with one of ' +\n      '`next`, `error`, `complete` properties.';\n    const nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    const observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n\n    function nextOrObserverValidator(p: any) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {}\n      try {\n        observerValidator(p);\n        const anyDefined =\n          typeUtils.isJustDef(p['next']) ||\n          typeUtils.isJustDef(p['error']) ||\n          typeUtils.isJustDef(p['complete']);\n        if (!anyDefined) {\n          throw '';\n        }\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n    const specs = [\n      fbsArgs.stringSpec(typeValidator),\n      fbsArgs.looseObjectSpec(nextOrObserverValidator, true),\n      fbsArgs.nullFunctionSpec(true),\n      fbsArgs.nullFunctionSpec(true)\n    ];\n    fbsArgs.validate('on', specs, arguments);\n    const self = this;\n\n    function makeBinder(\n      specs: ArgSpec[] | null\n    ): Subscribe<UploadTaskSnapshot> {\n      function binder(\n        nextOrObserver:\n          | NextFn<UploadTaskSnapshot>\n          | { [name: string]: string | null }\n          | null,\n        error?: ErrorFn | null,\n        opt_complete?: CompleteFn | null\n      ) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n        const observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return () => {\n          self.removeObserver_(observer);\n        };\n      }\n      return binder;\n    }\n\n    function binderNextOrObserverValidator(p: any) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n      nextOrObserverValidator(p);\n    }\n    const binderSpecs = [\n      fbsArgs.looseObjectSpec(binderNextOrObserverValidator),\n      fbsArgs.nullFunctionSpec(true),\n      fbsArgs.nullFunctionSpec(true)\n    ];\n    const typeOnly = !(\n      typeUtils.isJustDef(nextOrObserver) ||\n      typeUtils.isJustDef(error) ||\n      typeUtils.isJustDef(completed)\n    );\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  }\n\n  /**\n   * This object behaves like a Promise, and resolves with its snapshot data\n   * when the upload completes.\n   * @param onFulfilled The fulfillment callback. Promise chaining works as normal.\n   * @param onRejected The rejection callback.\n   */\n  then<U>(\n    onFulfilled?: ((value: UploadTaskSnapshot) => U | Promise<U>) | null,\n    onRejected?: ((error: any) => U | Promise<U>) | null\n  ): Promise<U> {\n    // These casts are needed so that TypeScript can infer the types of the\n    // resulting Promise.\n    return this.promise_.then<U>(\n      onFulfilled as (value: UploadTaskSnapshot) => U | Promise<U>,\n      onRejected as ((error: any) => Promise<never>) | null\n    );\n  }\n\n  /**\n   * Equivalent to calling `then(null, onRejected)`.\n   */\n  catch<T>(onRejected: (p1: Error) => T | Promise<T>): Promise<T> {\n    return this.then(null, onRejected);\n  }\n\n  /**\n   * Adds the given observer.\n   */\n  private addObserver_(observer: Observer<UploadTaskSnapshot>) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  }\n\n  /**\n   * Removes the given observer.\n   */\n  private removeObserver_(observer: Observer<UploadTaskSnapshot>) {\n    fbsArray.remove(this.observers_, observer);\n  }\n\n  private notifyObservers_() {\n    this.finishPromise_();\n    const observers = fbsArray.clone(this.observers_);\n    observers.forEach(observer => {\n      this.notifyObserver_(observer);\n    });\n  }\n\n  private finishPromise_() {\n    if (this.resolve_ !== null) {\n      let triggered = true;\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          const toCall = this.reject_ as ((p1: Error) => void);\n          fbsAsync(toCall.bind(null, this.error_ as Error))();\n          break;\n        default:\n          triggered = false;\n          break;\n      }\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  }\n\n  private notifyObserver_(observer: Observer<UploadTaskSnapshot>) {\n    const externalState = fbsTaskEnums.taskStateFromInternalTaskState(\n      this.state_\n    );\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n        break;\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n        break;\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_ as Error))();\n        }\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_ as Error))();\n        }\n    }\n  }\n\n  /**\n   * Resumes a paused task. Has no effect on a currently running or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  resume(): boolean {\n    fbsArgs.validate('resume', [], arguments);\n    const valid =\n      this.state_ === InternalTaskState.PAUSED ||\n      this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n    return valid;\n  }\n\n  /**\n   * Pauses a currently running task. Has no effect on a paused or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  pause(): boolean {\n    fbsArgs.validate('pause', [], arguments);\n    const valid = this.state_ === InternalTaskState.RUNNING;\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n    return valid;\n  }\n\n  /**\n   * Cancels a currently running or paused task. Has no effect on a complete or\n   * failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  cancel(): boolean {\n    fbsArgs.validate('cancel', [], arguments);\n    const valid =\n      this.state_ === InternalTaskState.RUNNING ||\n      this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n    return valid;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}