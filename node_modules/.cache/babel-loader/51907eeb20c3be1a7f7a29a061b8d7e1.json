{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Provides a Blob-like wrapper for various binary types (including the\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\n * making uploads possible in environments without the native Blob type.\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport { StringFormat } from './string';\nimport * as type from './type';\n/**\n * @param opt_elideCopy If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n */\n\nvar FbsBlob =\n/** @class */\nfunction () {\n  function FbsBlob(data, opt_elideCopy) {\n    var size = 0;\n    var blobType = '';\n\n    if (type.isNativeBlob(data)) {\n      this.data_ = data;\n      size = data.size;\n      blobType = data.type;\n    } else if (data instanceof ArrayBuffer) {\n      if (opt_elideCopy) {\n        this.data_ = new Uint8Array(data);\n      } else {\n        this.data_ = new Uint8Array(data.byteLength);\n        this.data_.set(new Uint8Array(data));\n      }\n\n      size = this.data_.length;\n    } else if (data instanceof Uint8Array) {\n      if (opt_elideCopy) {\n        this.data_ = data;\n      } else {\n        this.data_ = new Uint8Array(data.length);\n        this.data_.set(data);\n      }\n\n      size = data.length;\n    }\n\n    this.size_ = size;\n    this.type_ = blobType;\n  }\n\n  FbsBlob.prototype.size = function () {\n    return this.size_;\n  };\n\n  FbsBlob.prototype.type = function () {\n    return this.type_;\n  };\n\n  FbsBlob.prototype.slice = function (startByte, endByte) {\n    if (type.isNativeBlob(this.data_)) {\n      var realBlob = this.data_;\n      var sliced = fs.sliceBlob(realBlob, startByte, endByte);\n\n      if (sliced === null) {\n        return null;\n      }\n\n      return new FbsBlob(sliced);\n    } else {\n      var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\n      return new FbsBlob(slice, true);\n    }\n  };\n\n  FbsBlob.getBlob = function () {\n    var var_args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      var_args[_i] = arguments[_i];\n    }\n\n    if (type.isNativeBlobDefined()) {\n      var blobby = var_args.map(function (val) {\n        if (val instanceof FbsBlob) {\n          return val.data_;\n        } else {\n          return val;\n        }\n      });\n      return new FbsBlob(fs.getBlob.apply(null, blobby));\n    } else {\n      var uint8Arrays = var_args.map(function (val) {\n        if (type.isString(val)) {\n          return string.dataFromString(StringFormat.RAW, val).data;\n        } else {\n          // Blobs don't exist, so this has to be a Uint8Array.\n          return val.data_;\n        }\n      });\n      var finalLength_1 = 0;\n      uint8Arrays.forEach(function (array) {\n        finalLength_1 += array.byteLength;\n      });\n      var merged_1 = new Uint8Array(finalLength_1);\n      var index_1 = 0;\n      uint8Arrays.forEach(function (array) {\n        for (var i = 0; i < array.length; i++) {\n          merged_1[index_1++] = array[i];\n        }\n      });\n      return new FbsBlob(merged_1, true);\n    }\n  };\n\n  FbsBlob.prototype.uploadData = function () {\n    return this.data_;\n  };\n\n  return FbsBlob;\n}();\n\nexport { FbsBlob };","map":{"version":3,"sources":["../src/implementation/blob.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Provides a Blob-like wrapper for various binary types (including the\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\n * making uploads possible in environments without the native Blob type.\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport { StringFormat } from './string';\nimport * as type from './type';\n\n/**\n * @param opt_elideCopy If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n */\nexport class FbsBlob {\n  private data_: Blob | Uint8Array;\n  private size_: number;\n  private type_: string;\n\n  constructor(data: Blob | Uint8Array | ArrayBuffer, opt_elideCopy?: boolean) {\n    let size: number = 0;\n    let blobType: string = '';\n    if (type.isNativeBlob(data)) {\n      this.data_ = data as Blob;\n      size = (data as Blob).size;\n      blobType = (data as Blob).type;\n    } else if (data instanceof ArrayBuffer) {\n      if (opt_elideCopy) {\n        this.data_ = new Uint8Array(data);\n      } else {\n        this.data_ = new Uint8Array(data.byteLength);\n        this.data_.set(new Uint8Array(data));\n      }\n      size = this.data_.length;\n    } else if (data instanceof Uint8Array) {\n      if (opt_elideCopy) {\n        this.data_ = data as Uint8Array;\n      } else {\n        this.data_ = new Uint8Array(data.length);\n        this.data_.set(data as Uint8Array);\n      }\n      size = data.length;\n    }\n    this.size_ = size;\n    this.type_ = blobType;\n  }\n\n  size(): number {\n    return this.size_;\n  }\n\n  type(): string {\n    return this.type_;\n  }\n\n  slice(startByte: number, endByte: number): FbsBlob | null {\n    if (type.isNativeBlob(this.data_)) {\n      let realBlob = this.data_ as Blob;\n      let sliced = fs.sliceBlob(realBlob, startByte, endByte);\n      if (sliced === null) {\n        return null;\n      }\n      return new FbsBlob(sliced);\n    } else {\n      let slice = new Uint8Array(\n        (this.data_ as Uint8Array).buffer,\n        startByte,\n        endByte - startByte\n      );\n      return new FbsBlob(slice, true);\n    }\n  }\n\n  static getBlob(...var_args: (string | FbsBlob)[]): FbsBlob | null {\n    if (type.isNativeBlobDefined()) {\n      var blobby: (Blob | Uint8Array | string)[] = var_args.map(function(\n        val: string | FbsBlob\n      ): Blob | Uint8Array | string {\n        if (val instanceof FbsBlob) {\n          return val.data_;\n        } else {\n          return val;\n        }\n      });\n      return new FbsBlob(fs.getBlob.apply(null, blobby));\n    } else {\n      let uint8Arrays: Uint8Array[] = var_args.map(function(\n        val: string | FbsBlob\n      ): Uint8Array {\n        if (type.isString(val)) {\n          return string.dataFromString(StringFormat.RAW, val as string).data;\n        } else {\n          // Blobs don't exist, so this has to be a Uint8Array.\n          return (val as FbsBlob).data_ as Uint8Array;\n        }\n      });\n      let finalLength = 0;\n      uint8Arrays.forEach(function(array: Uint8Array): void {\n        finalLength += array.byteLength;\n      });\n      let merged = new Uint8Array(finalLength);\n      let index = 0;\n      uint8Arrays.forEach(function(array: Uint8Array) {\n        for (let i = 0; i < array.length; i++) {\n          merged[index++] = array[i];\n        }\n      });\n      return new FbsBlob(merged, true);\n    }\n  }\n\n  uploadData(): Blob | Uint8Array {\n    return this.data_;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}