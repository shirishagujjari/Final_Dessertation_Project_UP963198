{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nexport function noXform_(metadata, value) {\n  return value;\n}\n/**\n * @struct\n */\n\nvar Mapping =\n/** @class */\nfunction () {\n  function Mapping(server, opt_local, opt_writable, opt_xform) {\n    this.server = server;\n    this.local = opt_local || server;\n    this.writable = !!opt_writable;\n    this.xform = opt_xform || noXform_;\n  }\n\n  return Mapping;\n}();\n\nexport { Mapping };\nvar mappings_ = null;\nexport function xformPath(fullPath) {\n  var valid = type.isString(fullPath);\n\n  if (!valid || fullPath.length < 2) {\n    return fullPath;\n  } else {\n    fullPath = fullPath;\n    return path.lastComponent(fullPath);\n  }\n}\nexport function getMappings() {\n  if (mappings_) {\n    return mappings_;\n  }\n\n  var mappings = [];\n  mappings.push(new Mapping('bucket'));\n  mappings.push(new Mapping('generation'));\n  mappings.push(new Mapping('metageneration'));\n  mappings.push(new Mapping('name', 'fullPath', true));\n\n  function mappingsXformPath(metadata, fullPath) {\n    return xformPath(fullPath);\n  }\n\n  var nameMapping = new Mapping('name');\n  nameMapping.xform = mappingsXformPath;\n  mappings.push(nameMapping);\n  /**\n   * Coerces the second param to a number, if it is defined.\n   */\n\n  function xformSize(metadata, size) {\n    if (type.isDef(size)) {\n      return +size;\n    } else {\n      return size;\n    }\n  }\n\n  var sizeMapping = new Mapping('size');\n  sizeMapping.xform = xformSize;\n  mappings.push(sizeMapping);\n  mappings.push(new Mapping('timeCreated'));\n  mappings.push(new Mapping('updated'));\n  mappings.push(new Mapping('md5Hash', null, true));\n  mappings.push(new Mapping('cacheControl', null, true));\n  mappings.push(new Mapping('contentDisposition', null, true));\n  mappings.push(new Mapping('contentEncoding', null, true));\n  mappings.push(new Mapping('contentLanguage', null, true));\n  mappings.push(new Mapping('contentType', null, true));\n  mappings.push(new Mapping('metadata', 'customMetadata', true));\n  /**\n   * Transforms a comma-separated string of tokens into a list of download\n   * URLs.\n   */\n\n  function xformTokens(metadata, tokens) {\n    var valid = type.isString(tokens) && tokens.length > 0;\n\n    if (!valid) {\n      // This can happen if objects are uploaded through GCS and retrieved\n      // through list, so we don't want to throw an Error.\n      return [];\n    }\n\n    var encode = encodeURIComponent;\n    var tokensList = tokens.split(',');\n    var urls = tokensList.map(function (token) {\n      var bucket = metadata['bucket'];\n      var path = metadata['fullPath'];\n      var urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n      var base = UrlUtils.makeDownloadUrl(urlPart);\n      var queryString = UrlUtils.makeQueryString({\n        alt: 'media',\n        token: token\n      });\n      return base + queryString;\n    });\n    return urls;\n  }\n\n  mappings.push(new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));\n  mappings_ = mappings;\n  return mappings_;\n}\nexport function addRef(metadata, authWrapper) {\n  function generateRef() {\n    var bucket = metadata['bucket'];\n    var path = metadata['fullPath'];\n    var loc = new Location(bucket, path);\n    return authWrapper.makeStorageReference(loc);\n  }\n\n  Object.defineProperty(metadata, 'ref', {\n    get: generateRef\n  });\n}\nexport function fromResource(authWrapper, resource, mappings) {\n  var metadata = {};\n  metadata['type'] = 'file';\n  var len = mappings.length;\n\n  for (var i = 0; i < len; i++) {\n    var mapping = mappings[i];\n    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n  }\n\n  addRef(metadata, authWrapper);\n  return metadata;\n}\nexport function fromResourceString(authWrapper, resourceString, mappings) {\n  var obj = json.jsonObjectOrNull(resourceString);\n\n  if (obj === null) {\n    return null;\n  }\n\n  var resource = obj;\n  return fromResource(authWrapper, resource, mappings);\n}\nexport function toResourceString(metadata, mappings) {\n  var resource = {};\n  var len = mappings.length;\n\n  for (var i = 0; i < len; i++) {\n    var mapping = mappings[i];\n\n    if (mapping.writable) {\n      resource[mapping.server] = metadata[mapping.local];\n    }\n  }\n\n  return JSON.stringify(resource);\n}\nexport function metadataValidator(p) {\n  var validType = p && type.isObject(p);\n\n  if (!validType) {\n    throw 'Expected Metadata object.';\n  }\n\n  for (var key in p) {\n    var val = p[key];\n\n    if (key === 'customMetadata') {\n      if (!type.isObject(val)) {\n        throw 'Expected object for \\'customMetadata\\' mapping.';\n      }\n    } else {\n      if (type.isNonNullObject(val)) {\n        throw \"Mapping for '\" + key + \"' cannot be an object.\";\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../src/implementation/metadata.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAQH,OAAO,KAAK,IAAZ,MAAsB,QAAtB;AACA,SAAS,QAAT,QAAyB,YAAzB;AACA,OAAO,KAAK,IAAZ,MAAsB,QAAtB;AACA,OAAO,KAAK,IAAZ,MAAsB,QAAtB;AACA,OAAO,KAAK,QAAZ,MAA0B,OAA1B;AAEA,OAAM,SAAA,QAAA,CAAmB,QAAnB,EAAuC,KAAvC,EAAiD;AACrD,SAAO,KAAP;AACD;AAED;;AAEG;;AACH,IAAA,OAAA;AAAA;AAAA,YAAA;AAKE,WAAA,OAAA,CACS,MADT,EAEE,SAFF,EAGE,YAHF,EAIE,SAJF,EAImD;AAH1C,SAAA,MAAA,GAAA,MAAA;AAKP,SAAK,KAAL,GAAa,SAAS,IAAI,MAA1B;AACA,SAAK,QAAL,GAAgB,CAAC,CAAC,YAAlB;AACA,SAAK,KAAL,GAAa,SAAS,IAAI,QAA1B;AACD;;AACH,SAAA,OAAA;AAAC,CAfD,EAAA;;;AAoBA,IAAI,SAAS,GAAoB,IAAjC;AAEA,OAAM,SAAA,SAAA,CAAoB,QAApB,EAAiC;AACrC,MAAI,KAAK,GAAG,IAAI,CAAC,QAAL,CAAc,QAAd,CAAZ;;AACA,MAAI,CAAC,KAAD,IAAU,QAAQ,CAAC,MAAT,GAAkB,CAAhC,EAAmC;AACjC,WAAO,QAAP;AACD,GAFD,MAEO;AACL,IAAA,QAAQ,GAAG,QAAX;AACA,WAAO,IAAI,CAAC,aAAL,CAAmB,QAAnB,CAAP;AACD;AACF;AAED,OAAM,SAAA,WAAA,GAAA;AACJ,MAAI,SAAJ,EAAe;AACb,WAAO,SAAP;AACD;;AACD,MAAI,QAAQ,GAAG,EAAf;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,QAAZ,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,YAAZ,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,gBAAZ,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,MAAZ,EAAoB,UAApB,EAAgC,IAAhC,CAAd;;AAEA,WAAA,iBAAA,CAA2B,QAA3B,EAA+C,QAA/C,EAA4D;AAC1D,WAAO,SAAS,CAAC,QAAD,CAAhB;AACD;;AACD,MAAI,WAAW,GAAG,IAAI,OAAJ,CAAY,MAAZ,CAAlB;AACA,EAAA,WAAW,CAAC,KAAZ,GAAoB,iBAApB;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,WAAd;AAEA;;AAEG;;AACH,WAAA,SAAA,CAAmB,QAAnB,EAAuC,IAAvC,EAAgD;AAC9C,QAAI,IAAI,CAAC,KAAL,CAAW,IAAX,CAAJ,EAAsB;AACpB,aAAO,CAAE,IAAT;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF;;AACD,MAAI,WAAW,GAAG,IAAI,OAAJ,CAAY,MAAZ,CAAlB;AACA,EAAA,WAAW,CAAC,KAAZ,GAAoB,SAApB;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,WAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,aAAZ,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,SAAZ,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,SAAZ,EAAuB,IAAvB,EAA6B,IAA7B,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,cAAZ,EAA4B,IAA5B,EAAkC,IAAlC,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,oBAAZ,EAAkC,IAAlC,EAAwC,IAAxC,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,iBAAZ,EAA+B,IAA/B,EAAqC,IAArC,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,iBAAZ,EAA+B,IAA/B,EAAqC,IAArC,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,aAAZ,EAA2B,IAA3B,EAAiC,IAAjC,CAAd;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,OAAJ,CAAY,UAAZ,EAAwB,gBAAxB,EAA0C,IAA1C,CAAd;AAEA;;;AAGG;;AACH,WAAA,WAAA,CAAqB,QAArB,EAAyC,MAAzC,EAAoD;AAClD,QAAI,KAAK,GAAG,IAAI,CAAC,QAAL,CAAc,MAAd,KAAyB,MAAM,CAAC,MAAP,GAAgB,CAArD;;AACA,QAAI,CAAC,KAAL,EAAY;AACV;AACA;AACA,aAAO,EAAP;AACD;;AACD,QAAI,MAAM,GAAG,kBAAb;AACA,QAAI,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,GAAb,CAAjB;AACA,QAAI,IAAI,GAAG,UAAU,CAAC,GAAX,CAAe,UAAS,KAAT,EAAsB;AAC9C,UAAI,MAAM,GAAW,QAAQ,CAAC,QAAD,CAA7B;AACA,UAAI,IAAI,GAAW,QAAQ,CAAC,UAAD,CAA3B;AACA,UAAI,OAAO,GAAG,QAAQ,MAAM,CAAC,MAAD,CAAd,GAAyB,KAAzB,GAAiC,MAAM,CAAC,IAAD,CAArD;AACA,UAAI,IAAI,GAAG,QAAQ,CAAC,eAAT,CAAyB,OAAzB,CAAX;AACA,UAAI,WAAW,GAAG,QAAQ,CAAC,eAAT,CAAyB;AACzC,QAAA,GAAG,EAAE,OADoC;AAEzC,QAAA,KAAK,EAAE;AAFkC,OAAzB,CAAlB;AAIA,aAAO,IAAI,GAAG,WAAd;AACD,KAVU,CAAX;AAWA,WAAO,IAAP;AACD;;AACD,EAAA,QAAQ,CAAC,IAAT,CACE,IAAI,OAAJ,CAAY,gBAAZ,EAA8B,cAA9B,EAA8C,KAA9C,EAAqD,WAArD,CADF;AAGA,EAAA,SAAS,GAAG,QAAZ;AACA,SAAO,SAAP;AACD;AAED,OAAM,SAAA,MAAA,CAAiB,QAAjB,EAAqC,WAArC,EAA6D;AACjE,WAAA,WAAA,GAAA;AACE,QAAI,MAAM,GAAW,QAAQ,CAAC,QAAD,CAA7B;AACA,QAAI,IAAI,GAAW,QAAQ,CAAC,UAAD,CAA3B;AACA,QAAI,GAAG,GAAG,IAAI,QAAJ,CAAa,MAAb,EAAqB,IAArB,CAAV;AACA,WAAO,WAAW,CAAC,oBAAZ,CAAiC,GAAjC,CAAP;AACD;;AACD,EAAA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,KAAhC,EAAuC;AAAE,IAAA,GAAG,EAAE;AAAP,GAAvC;AACD;AAED,OAAM,SAAA,YAAA,CACJ,WADI,EAEJ,QAFI,EAGJ,QAHI,EAGc;AAElB,MAAI,QAAQ,GAAa,EAAzB;AACA,EAAA,QAAQ,CAAC,MAAD,CAAR,GAAmB,MAAnB;AACA,MAAI,GAAG,GAAG,QAAQ,CAAC,MAAnB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,QAAI,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAtB;AACA,IAAA,QAAQ,CAAC,OAAO,CAAC,KAAT,CAAR,GAA0B,OAAO,CAAC,KAAR,CAAc,QAAd,EAAwB,QAAQ,CAAC,OAAO,CAAC,MAAT,CAAhC,CAA1B;AACD;;AACD,EAAA,MAAM,CAAC,QAAD,EAAW,WAAX,CAAN;AACA,SAAO,QAAP;AACD;AAED,OAAM,SAAA,kBAAA,CACJ,WADI,EAEJ,cAFI,EAGJ,QAHI,EAGc;AAElB,MAAI,GAAG,GAAG,IAAI,CAAC,gBAAL,CAAsB,cAAtB,CAAV;;AACA,MAAI,GAAG,KAAK,IAAZ,EAAkB;AAChB,WAAO,IAAP;AACD;;AACD,MAAI,QAAQ,GAAG,GAAf;AACA,SAAO,YAAY,CAAC,WAAD,EAAc,QAAd,EAAwB,QAAxB,CAAnB;AACD;AAED,OAAM,SAAA,gBAAA,CACJ,QADI,EAEJ,QAFI,EAEc;AAElB,MAAI,QAAQ,GAER,EAFJ;AAGA,MAAI,GAAG,GAAG,QAAQ,CAAC,MAAnB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,QAAI,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAtB;;AACA,QAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,MAAA,QAAQ,CAAC,OAAO,CAAC,MAAT,CAAR,GAA2B,QAAQ,CAAC,OAAO,CAAC,KAAT,CAAnC;AACD;AACF;;AACD,SAAO,IAAI,CAAC,SAAL,CAAe,QAAf,CAAP;AACD;AAED,OAAM,SAAA,iBAAA,CAA4B,CAA5B,EAAkC;AACtC,MAAI,SAAS,GAAG,CAAC,IAAI,IAAI,CAAC,QAAL,CAAc,CAAd,CAArB;;AACA,MAAI,CAAC,SAAL,EAAgB;AACd,UAAM,2BAAN;AACD;;AACD,OAAK,IAAI,GAAT,IAAgB,CAAhB,EAAmB;AACjB,QAAI,GAAG,GAAG,CAAC,CAAC,GAAD,CAAX;;AACA,QAAI,GAAG,KAAK,gBAAZ,EAA8B;AAC5B,UAAI,CAAC,IAAI,CAAC,QAAL,CAAc,GAAd,CAAL,EAAyB;AACvB,cAAM,iDAAN;AACD;AACF,KAJD,MAIO;AACL,UAAI,IAAI,CAAC,eAAL,CAAqB,GAArB,CAAJ,EAA+B;AAC7B,cAAM,kBAAkB,GAAlB,GAAwB,wBAA9B;AACD;AACF;AACF;AACF","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Documentation for the metadata format\n */\nimport { Metadata } from '../metadata';\n\nimport { AuthWrapper } from './authwrapper';\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n\nexport function noXform_(metadata: Metadata, value: any): any {\n  return value;\n}\n\n/**\n * @struct\n */\nexport class Mapping {\n  local: string;\n  writable: boolean;\n  xform: (p1: Metadata, p2: any) => any;\n\n  constructor(\n    public server: string,\n    opt_local?: string | null,\n    opt_writable?: boolean,\n    opt_xform?: (p1: Metadata, p2: any) => any | null\n  ) {\n    this.local = opt_local || server;\n    this.writable = !!opt_writable;\n    this.xform = opt_xform || noXform_;\n  }\n}\ntype Mappings = Mapping[];\n\nexport { Mappings };\n\nlet mappings_: Mappings | null = null;\n\nexport function xformPath(fullPath: any): string {\n  let valid = type.isString(fullPath);\n  if (!valid || fullPath.length < 2) {\n    return fullPath;\n  } else {\n    fullPath = fullPath as string;\n    return path.lastComponent(fullPath);\n  }\n}\n\nexport function getMappings(): Mappings {\n  if (mappings_) {\n    return mappings_;\n  }\n  let mappings = [];\n  mappings.push(new Mapping('bucket'));\n  mappings.push(new Mapping('generation'));\n  mappings.push(new Mapping('metageneration'));\n  mappings.push(new Mapping('name', 'fullPath', true));\n\n  function mappingsXformPath(metadata: Metadata, fullPath: any): string {\n    return xformPath(fullPath);\n  }\n  let nameMapping = new Mapping('name');\n  nameMapping.xform = mappingsXformPath;\n  mappings.push(nameMapping);\n\n  /**\n   * Coerces the second param to a number, if it is defined.\n   */\n  function xformSize(metadata: Metadata, size: any): number | null | undefined {\n    if (type.isDef(size)) {\n      return +(size as number);\n    } else {\n      return size;\n    }\n  }\n  let sizeMapping = new Mapping('size');\n  sizeMapping.xform = xformSize;\n  mappings.push(sizeMapping);\n  mappings.push(new Mapping('timeCreated'));\n  mappings.push(new Mapping('updated'));\n  mappings.push(new Mapping('md5Hash', null, true));\n  mappings.push(new Mapping('cacheControl', null, true));\n  mappings.push(new Mapping('contentDisposition', null, true));\n  mappings.push(new Mapping('contentEncoding', null, true));\n  mappings.push(new Mapping('contentLanguage', null, true));\n  mappings.push(new Mapping('contentType', null, true));\n  mappings.push(new Mapping('metadata', 'customMetadata', true));\n\n  /**\n   * Transforms a comma-separated string of tokens into a list of download\n   * URLs.\n   */\n  function xformTokens(metadata: Metadata, tokens: any): string[] {\n    let valid = type.isString(tokens) && tokens.length > 0;\n    if (!valid) {\n      // This can happen if objects are uploaded through GCS and retrieved\n      // through list, so we don't want to throw an Error.\n      return [];\n    }\n    let encode = encodeURIComponent;\n    let tokensList = tokens.split(',');\n    let urls = tokensList.map(function(token: string) {\n      let bucket: string = metadata['bucket'] as string;\n      let path: string = metadata['fullPath'] as string;\n      let urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n      let base = UrlUtils.makeDownloadUrl(urlPart);\n      let queryString = UrlUtils.makeQueryString({\n        alt: 'media',\n        token: token\n      });\n      return base + queryString;\n    });\n    return urls;\n  }\n  mappings.push(\n    new Mapping('downloadTokens', 'downloadURLs', false, xformTokens)\n  );\n  mappings_ = mappings;\n  return mappings_;\n}\n\nexport function addRef(metadata: Metadata, authWrapper: AuthWrapper) {\n  function generateRef() {\n    let bucket: string = metadata['bucket'] as string;\n    let path: string = metadata['fullPath'] as string;\n    let loc = new Location(bucket, path);\n    return authWrapper.makeStorageReference(loc);\n  }\n  Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\n\nexport function fromResource(\n  authWrapper: AuthWrapper,\n  resource: { [name: string]: any },\n  mappings: Mappings\n): Metadata {\n  let metadata: Metadata = {} as Metadata;\n  metadata['type'] = 'file';\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n  }\n  addRef(metadata, authWrapper);\n  return metadata;\n}\n\nexport function fromResourceString(\n  authWrapper: AuthWrapper,\n  resourceString: string,\n  mappings: Mappings\n): Metadata | null {\n  let obj = json.jsonObjectOrNull(resourceString);\n  if (obj === null) {\n    return null;\n  }\n  let resource = obj as Metadata;\n  return fromResource(authWrapper, resource, mappings);\n}\n\nexport function toResourceString(\n  metadata: Metadata,\n  mappings: Mappings\n): string {\n  let resource: {\n    [prop: string]: any;\n  } = {};\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    if (mapping.writable) {\n      resource[mapping.server] = metadata[mapping.local];\n    }\n  }\n  return JSON.stringify(resource);\n}\n\nexport function metadataValidator(p: any) {\n  let validType = p && type.isObject(p);\n  if (!validType) {\n    throw 'Expected Metadata object.';\n  }\n  for (let key in p) {\n    let val = p[key];\n    if (key === 'customMetadata') {\n      if (!type.isObject(val)) {\n        throw 'Expected object for \\'customMetadata\\' mapping.';\n      }\n    } else {\n      if (type.isNonNullObject(val)) {\n        throw \"Mapping for '\" + key + \"' cannot be an object.\";\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}