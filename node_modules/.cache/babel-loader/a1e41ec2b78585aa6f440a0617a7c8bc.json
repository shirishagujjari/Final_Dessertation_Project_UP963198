{"ast":null,"code":"import * as constants from './constants';\nimport * as errorsExports from './error';\nimport { FailRequest } from './failrequest';\nimport { Location } from './location';\nimport * as promiseimpl from './promise_external';\nimport { RequestMap } from './requestmap';\nimport * as type from './type';\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\n\nvar AuthWrapper =\n/** @class */\nfunction () {\n  function AuthWrapper(app, maker, requestMaker, service, pool) {\n    this.bucket_ = null;\n    this.deleted_ = false;\n    this.app_ = app;\n\n    if (this.app_ !== null) {\n      var options = this.app_.options;\n\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n\n  AuthWrapper.extractBucket_ = function (config) {\n    var bucketString = config[constants.configOption] || null;\n\n    if (bucketString == null) {\n      return null;\n    }\n\n    var loc = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  };\n\n  AuthWrapper.prototype.getAuthToken = function () {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (this.app_ !== null && type.isDef(this.app_.INTERNAL) && type.isDef(this.app_.INTERNAL.getToken)) {\n      return this.app_.INTERNAL.getToken().then(function (response) {\n        if (response !== null) {\n          return response.accessToken;\n        } else {\n          return null;\n        }\n      }, function (_error) {\n        return null;\n      });\n    } else {\n      return promiseimpl.resolve(null);\n    }\n  };\n\n  AuthWrapper.prototype.bucket = function () {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  };\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n\n\n  AuthWrapper.prototype.service = function () {\n    return this.service_;\n  };\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n\n\n  AuthWrapper.prototype.makeStorageReference = function (loc) {\n    return this.storageRefMaker_(this, loc);\n  };\n\n  AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) {\n    if (!this.deleted_) {\n      var request = this.requestMaker_(requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  };\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n\n\n  AuthWrapper.prototype.deleteApp = function () {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  };\n\n  AuthWrapper.prototype.maxUploadRetryTime = function () {\n    return this.maxUploadRetryTime_;\n  };\n\n  AuthWrapper.prototype.setMaxUploadRetryTime = function (time) {\n    this.maxUploadRetryTime_ = time;\n  };\n\n  AuthWrapper.prototype.maxOperationRetryTime = function () {\n    return this.maxOperationRetryTime_;\n  };\n\n  AuthWrapper.prototype.setMaxOperationRetryTime = function (time) {\n    this.maxOperationRetryTime_ = time;\n  };\n\n  return AuthWrapper;\n}();\n\nexport { AuthWrapper };","map":{"version":3,"sources":["../src/implementation/authwrapper.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Reference } from '../reference';\nimport { Service } from '../service';\nimport * as constants from './constants';\nimport * as errorsExports from './error';\nimport { errors } from './error';\nimport { FailRequest } from './failrequest';\nimport { Location } from './location';\nimport * as promiseimpl from './promise_external';\nimport { Request } from './request';\nimport { RequestInfo } from './requestinfo';\nimport { requestMaker } from './requestmaker';\nimport { RequestMap } from './requestmap';\nimport * as type from './type';\nimport { XhrIoPool } from './xhriopool';\nimport { FirebaseApp, FirebaseAuthTokenData } from '@firebase/app';\n\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nexport class AuthWrapper {\n  private app_: FirebaseApp | null;\n  private bucket_: string | null = null;\n\n  /**\n  maker\n     */\n  private storageRefMaker_: (p1: AuthWrapper, p2: Location) => Reference;\n  private requestMaker_: requestMaker;\n  private pool_: XhrIoPool;\n  private service_: Service;\n  private maxOperationRetryTime_: number;\n  private maxUploadRetryTime_: number;\n  private requestMap_: RequestMap;\n  private deleted_: boolean = false;\n\n  constructor(\n    app: FirebaseApp | null,\n    maker: (p1: AuthWrapper, p2: Location) => Reference,\n    requestMaker: requestMaker,\n    service: Service,\n    pool: XhrIoPool\n  ) {\n    this.app_ = app;\n    if (this.app_ !== null) {\n      let options = this.app_.options;\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n\n  private static extractBucket_(config: {\n    [prop: string]: any;\n  }): string | null {\n    let bucketString = config[constants.configOption] || null;\n    if (bucketString == null) {\n      return null;\n    }\n    let loc: Location = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  }\n\n  getAuthToken(): Promise<string | null> {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (\n      this.app_ !== null &&\n      type.isDef(this.app_.INTERNAL) &&\n      type.isDef(this.app_.INTERNAL.getToken)\n    ) {\n      return this.app_.INTERNAL.getToken().then(\n        function(response: FirebaseAuthTokenData | null): string | null {\n          if (response !== null) {\n            return response.accessToken;\n          } else {\n            return null;\n          }\n        },\n        function(_error) {\n          return null;\n        }\n      );\n    } else {\n      return promiseimpl.resolve(null) as Promise<string | null>;\n    }\n  }\n\n  bucket(): string | null {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  }\n\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n  service(): Service {\n    return this.service_;\n  }\n\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n  makeStorageReference(loc: Location): Reference {\n    return this.storageRefMaker_(this, loc);\n  }\n\n  makeRequest<T>(\n    requestInfo: RequestInfo<T>,\n    authToken: string | null\n  ): Request<T> {\n    if (!this.deleted_) {\n      let request = this.requestMaker_(requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  }\n\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n  deleteApp() {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  }\n\n  maxUploadRetryTime(): number {\n    return this.maxUploadRetryTime_;\n  }\n\n  setMaxUploadRetryTime(time: number) {\n    this.maxUploadRetryTime_ = time;\n  }\n\n  maxOperationRetryTime(): number {\n    return this.maxOperationRetryTime_;\n  }\n\n  setMaxOperationRetryTime(time: number) {\n    this.maxOperationRetryTime_ = time;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}